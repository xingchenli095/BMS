/**
 * \file
 *
 * \brief AUTOSAR Rte
 *
 * This file contains the implementation of the AUTOSAR
 * module Rte.
 *
 * \version 6.8.4
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2022 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

/*
 * This file contains an Rte component template / example code
 *
 * This file has been automatically generated by
 * EB tresos AutoCore Rte Generator Version 6.8.4
 * on Thu Aug 31 17:25:22 CST 2023. !!!IGNORE-LINE!!!
 */

/*
 * \addtogroup Rte Runtime Environment
 * @{
 */

/* ==================[Includes]=============================================== */
#include <Rte_SWC_CyclicCounter.h>

/* ==================[Definition of functions with external linkage]========== */
/* ------------------------[runnable entity skeletons]------------------------ */
#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_Cyclic (void)
{
  uint8 ret_IrvRead;
  uint8 arg_IrvWrite_data = 0U;
  uint8 arg_Write_data = 0U;
  Std_ReturnType ret_Write;
  uint8 arg_Receive_data;
  Std_ReturnType ret_Receive;
  uint8 arg_Call_InstanceId = 0U;
  uint8 arg_Call_ApiId = 0U;
  uint8 arg_Call_ErrorId = 0U;
  Std_ReturnType ret_Call;
  uint32 arg_Call_value = 0U;
  Std_ReturnType ret_Call_0;
  ComM_ModeType arg_Call_ComMode = 0U;
  Std_ReturnType ret_Call_1;

  ret_IrvRead = Rte_IrvRead_Cyclic_CurrentCounterValue();
  (void)ret_IrvRead;
  Rte_IrvWrite_Cyclic_CurrentCounterValue(arg_IrvWrite_data);
  ret_Write = Rte_Write_P_CounterOut_CounterValue(arg_Write_data);
  (void)ret_Write;
  ret_Receive = Rte_Receive_R_SpecialHandling_EventMessage(&arg_Receive_data);
  (void)ret_Receive;
  ret_Call = Rte_Call_R_CyclicCounterDet_ReportError(arg_Call_InstanceId, arg_Call_ApiId, arg_Call_ErrorId);
  (void)ret_Call;
  ret_Call_0 = Rte_Call_R_MyLED_SetDiscreteValue(arg_Call_value);
  (void)ret_Call_0;
  ret_Call_1 = Rte_Call_UR_ComMUser_0_RequestComMode(arg_Call_ComMode);
  (void)ret_Call_1;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_Cyclic (void) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_Cyclic_FD (void)
{
  uint8 ret_IrvRead;
  uint8 arg_IrvWrite_data = 0U;
  uint8 arg_Write_data = 0U;
  Std_ReturnType ret_Write;

  ret_IrvRead = Rte_IrvRead_Cyclic_FD_CurrentCounterValue_FD();
  (void)ret_IrvRead;
  Rte_IrvWrite_Cyclic_FD_CurrentCounterValue_FD(arg_IrvWrite_data);
  ret_Write = Rte_Write_P_CounterOut_FD_CounterValue_FD(arg_Write_data);
  (void)ret_Write;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_Cyclic_FD (void) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_Init (void)
{
  uint8 arg_IrvWrite_data = 0U;
  ComM_ModeType arg_Call_ComMode = 0U;
  Std_ReturnType ret_Call;
  uint8 ret_CData;

  Rte_IrvWrite_Init_CurrentCounterValue(arg_IrvWrite_data);
  ret_Call = Rte_Call_UR_ComMUser_0_RequestComMode(arg_Call_ComMode);
  (void)ret_Call;
  ret_CData = Rte_CData_PrmCounterValue();
  (void)ret_CData;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_Init (void) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_SetCounter (uint8 newCounterValue, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) returnSum)
{
  uint8 ret_IrvRead;
  uint8 arg_IrvWrite_data = 0U;

  ret_IrvRead = Rte_IrvRead_SetCounter_CurrentCounterValue();
  (void)ret_IrvRead;
  Rte_IrvWrite_SetCounter_CurrentCounterValue(arg_IrvWrite_data);
  /* suppress compiler warnings about unused arguments */
  (void)newCounterValue;
  (void)*returnSum;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_SetCounter (uint8 newCounterValue, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) returnSum) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_SetCounter_FD (uint8 newCounterValue, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) returnSum)
{
  uint8 ret_IrvRead;
  uint8 arg_IrvWrite_data = 0U;

  ret_IrvRead = Rte_IrvRead_SetCounter_FD_CurrentCounterValue_FD();
  (void)ret_IrvRead;
  Rte_IrvWrite_SetCounter_FD_CurrentCounterValue_FD(arg_IrvWrite_data);
  /* suppress compiler warnings about unused arguments */
  (void)newCounterValue;
  (void)*returnSum;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_SetCounter_FD (uint8 newCounterValue, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) returnSum) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

#define SWC_CyclicCounter_START_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>
FUNC(void, RTE_CODE) SWC_CyclicCounter_Shutdown (void)
{
  uint8 ret_IrvRead;
  boolean arg_Call_BlockChanged = 0U;
  Std_ReturnType ret_Call;

  ret_IrvRead = Rte_IrvRead_Shutdown_CurrentCounterValue();
  (void)ret_IrvRead;
  ret_Call = Rte_Call_PS_PersistentCounterValue_SetRamBlockStatus(arg_Call_BlockChanged);
  (void)ret_Call;

} /* FUNC(void, RTE_CODE) SWC_CyclicCounter_Shutdown (void) */

#define SWC_CyclicCounter_STOP_SEC_CODE
#include <SWC_CyclicCounter_MemMap.h>

/*
  ------------------------[runnable-independent API]-------------------------

  Copy and paste the following API to those runnable entity functions where
  you want to use them.

  ------------------------[port handle API]----------------------------------
  ------------------------[per instance memory API]--------------------------
  Rte_PimType_SWC_CyclicCounter_CounterValueType pim = Rte_Pim_PimCounterValue();
 */

/** @} doxygen end group definition  */
/* ==================[end of file]============================================ */
