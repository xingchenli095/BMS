
Marking local functions: Power_Ip_MC_ME_ConfigureCore Power_Ip_MC_ME_ConfigureCOFB Power_Ip_MC_ME_ConfigurePartitionClock Power_Ip_MC_ME_TriggerCoreUpdate Power_Ip_MC_ME_TriggerCofbUpdate Power_Ip_MC_ME_TriggerPartitionUpdate Power_Ip_MC_ME_TriggerModeUpdate Power_Ip_MC_ME_WriteControlKeys


Marking externally visible functions: Power_Ip_MC_ME_SocTriggerResetEvent Power_Ip_MC_ME_DisablePartitionClock Power_Ip_MC_ME_EnablePartitionClock Power_Ip_MC_ME_ConfigCoreCOFBClock


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

Power_Ip_ReportPowerErrors/15 (Power_Ip_ReportPowerErrors) @06fa9c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Power_Ip_MC_ME_ConfigurePartitionClock/6 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCOFB/7 
  Calls: 
Power_Ip_TimeoutExpired/14 (Power_Ip_TimeoutExpired) @06fa9b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Power_Ip_MC_ME_ConfigurePartitionClock/6 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCOFB/7 
  Calls: 
Power_Ip_StartTimeout/13 (Power_Ip_StartTimeout) @06fa9a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Power_Ip_MC_ME_ConfigurePartitionClock/6 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCOFB/7 
  Calls: 
Power_Ip_MC_ME_SocTriggerResetEvent/12 (Power_Ip_MC_ME_SocTriggerResetEvent) @06fa97e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Power_Ip_MC_ME_TriggerModeUpdate/2 
Power_Ip_MC_ME_DisablePartitionClock/11 (Power_Ip_MC_ME_DisablePartitionClock) @06fa9460
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Power_Ip_MC_ME_ConfigurePartitionClock/6 
Power_Ip_MC_ME_EnablePartitionClock/10 (Power_Ip_MC_ME_EnablePartitionClock) @06fa92a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Power_Ip_MC_ME_ConfigurePartitionClock/6 
Power_Ip_MC_ME_ConfigCoreCOFBClock/9 (Power_Ip_MC_ME_ConfigCoreCOFBClock) @06fa90e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Power_Ip_MC_ME_ConfigureCore/8 Power_Ip_MC_ME_ConfigureCOFB/7 
Power_Ip_MC_ME_ConfigureCore/8 (Power_Ip_MC_ME_ConfigureCore) @06f8cee0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_ConfigCoreCOFBClock/9 
  Calls: Power_Ip_ReportPowerErrors/15 Power_Ip_TimeoutExpired/14 Power_Ip_StartTimeout/13 Power_Ip_MC_ME_TriggerCoreUpdate/5 Power_Ip_ReportPowerErrors/15 Power_Ip_TimeoutExpired/14 Power_Ip_StartTimeout/13 
Power_Ip_MC_ME_ConfigureCOFB/7 (Power_Ip_MC_ME_ConfigureCOFB) @06f8cd20
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_ConfigCoreCOFBClock/9 
  Calls: Power_Ip_ReportPowerErrors/15 Power_Ip_TimeoutExpired/14 Power_Ip_StartTimeout/13 Power_Ip_MC_ME_TriggerCofbUpdate/4 
Power_Ip_MC_ME_ConfigurePartitionClock/6 (Power_Ip_MC_ME_ConfigurePartitionClock) @06f8cb60
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_DisablePartitionClock/11 Power_Ip_MC_ME_EnablePartitionClock/10 
  Calls: Power_Ip_ReportPowerErrors/15 Power_Ip_TimeoutExpired/14 Power_Ip_StartTimeout/13 Power_Ip_MC_ME_TriggerPartitionUpdate/3 
Power_Ip_MC_ME_TriggerCoreUpdate/5 (Power_Ip_MC_ME_TriggerCoreUpdate) @06f8c9a0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_ConfigureCore/8 
  Calls: Power_Ip_MC_ME_WriteControlKeys/1 
Power_Ip_MC_ME_TriggerCofbUpdate/4 (Power_Ip_MC_ME_TriggerCofbUpdate) @06f8c7e0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_ConfigureCOFB/7 
  Calls: Power_Ip_MC_ME_WriteControlKeys/1 
Power_Ip_MC_ME_TriggerPartitionUpdate/3 (Power_Ip_MC_ME_TriggerPartitionUpdate) @06f8c620
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_ConfigurePartitionClock/6 
  Calls: Power_Ip_MC_ME_WriteControlKeys/1 
Power_Ip_MC_ME_TriggerModeUpdate/2 (Power_Ip_MC_ME_TriggerModeUpdate) @06f8c460
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_SocTriggerResetEvent/12 
  Calls: Power_Ip_MC_ME_WriteControlKeys/1 
Power_Ip_MC_ME_WriteControlKeys/1 (Power_Ip_MC_ME_WriteControlKeys) @06f8c1c0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: Power_Ip_pxMC_ME/0 (read)Power_Ip_pxMC_ME/0 (read)
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Power_Ip_MC_ME_TriggerModeUpdate/2 Power_Ip_MC_ME_TriggerPartitionUpdate/3 Power_Ip_MC_ME_TriggerCoreUpdate/5 Power_Ip_MC_ME_TriggerCofbUpdate/4 
  Calls: 
Power_Ip_pxMC_ME/0 (Power_Ip_pxMC_ME) @06f49cf0
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: Power_Ip_MC_ME_ConfigureCOFB/7 (read)Power_Ip_MC_ME_ConfigureCOFB/7 (read)Power_Ip_MC_ME_TriggerCofbUpdate/4 (read)Power_Ip_MC_ME_TriggerCofbUpdate/4 (read)Power_Ip_MC_ME_WriteControlKeys/1 (read)Power_Ip_MC_ME_WriteControlKeys/1 (read)Power_Ip_MC_ME_ConfigureCore/8 (read)Power_Ip_MC_ME_ConfigureCore/8 (read)Power_Ip_MC_ME_ConfigureCore/8 (read)Power_Ip_MC_ME_TriggerCoreUpdate/5 (read)Power_Ip_MC_ME_TriggerCoreUpdate/5 (read)Power_Ip_MC_ME_ConfigurePartitionClock/6 (read)Power_Ip_MC_ME_ConfigurePartitionClock/6 (read)Power_Ip_MC_ME_ConfigurePartitionClock/6 (read)Power_Ip_MC_ME_TriggerPartitionUpdate/3 (read)Power_Ip_MC_ME_TriggerPartitionUpdate/3 (read)Power_Ip_MC_ME_SocTriggerResetEvent/12 (read)Power_Ip_MC_ME_SocTriggerResetEvent/12 (read)Power_Ip_MC_ME_TriggerModeUpdate/2 (read)
  Availability: available
  Varpool flags: initialized
Power_Ip_MC_ME_SocTriggerResetEvent (Power_Ip_PowerModeType PowerMode)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  if (PowerMode == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.21_1 = Power_Ip_pxMC_ME;
  Power_Ip_pxMC_ME.21_1->MODE_CONF = 1;
  goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (PowerMode == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.22_2 = Power_Ip_pxMC_ME;
  Power_Ip_pxMC_ME.22_2->MODE_CONF = 2;

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_TriggerModeUpdate ();
  return;

}


Power_Ip_MC_ME_DisablePartitionClock (const struct Power_Ip_MC_ME_ModeConfigType * ModeConfigPtr)
{
  uint8 PartitionIndex;
  const struct Power_Ip_MC_ME_PartitionConfigType * TempPartitionConfig;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempPartitionConfig = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  PartitionIndex = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = ModeConfigPtr->ArrayPartitionConfigPtr;
  _2 = (int) PartitionIndex;
  TempPartitionConfig = &*_1[_2];
  # DEBUG BEGIN_STMT
  _3 = TempPartitionConfig->PartitionUnderMcuControl;
  if (_3 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _4 = TempPartitionConfig->PartitionPowerUnderMcuControl;
  if (_4 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = TempPartitionConfig->PartitionPconfRegValue;
  _6 = _5 & 1;
  if (_6 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_ConfigurePartitionClock (TempPartitionConfig);

  <bb 7> :
  # DEBUG BEGIN_STMT
  PartitionIndex = PartitionIndex + 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (PartitionIndex <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}


Power_Ip_MC_ME_EnablePartitionClock (const struct Power_Ip_MC_ME_ModeConfigType * ModeConfigPtr)
{
  uint8 PartitionIndex;
  const struct Power_Ip_MC_ME_PartitionConfigType * TempPartitionConfig;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempPartitionConfig = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  PartitionIndex = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = ModeConfigPtr->ArrayPartitionConfigPtr;
  _2 = (int) PartitionIndex;
  TempPartitionConfig = &*_1[_2];
  # DEBUG BEGIN_STMT
  _3 = TempPartitionConfig->PartitionUnderMcuControl;
  if (_3 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _4 = TempPartitionConfig->PartitionPowerUnderMcuControl;
  if (_4 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = TempPartitionConfig->PartitionPconfRegValue;
  _6 = _5 & 1;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_ConfigurePartitionClock (TempPartitionConfig);

  <bb 7> :
  # DEBUG BEGIN_STMT
  PartitionIndex = PartitionIndex + 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (PartitionIndex <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}


Power_Ip_MC_ME_ConfigCoreCOFBClock (const struct Power_Ip_MC_ME_ModeConfigType * ModeConfigPtr)
{
  uint8 CoreIndex;
  uint8 CofbIndex;
  uint8 PartitionIndex;
  const struct Power_Ip_MC_ME_PartitionConfigType * TempPartitionConfig;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempPartitionConfig = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  PartitionIndex = 0;
  goto <bb 15>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = ModeConfigPtr->ArrayPartitionConfigPtr;
  _2 = (int) PartitionIndex;
  TempPartitionConfig = &*_1[_2];
  # DEBUG BEGIN_STMT
  _3 = TempPartitionConfig->PartitionUnderMcuControl;
  if (_3 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  CofbIndex = 0;
  goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _4 = TempPartitionConfig->ArrayPartitionCofbConfigPtr;
  _5 = (int) CofbIndex;
  _6 = *_4[_5].CofbUnderMcuControl;
  if (_6 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _7 = TempPartitionConfig->ArrayPartitionCofbConfigPtr;
  _8 = (int) CofbIndex;
  _9 = &*_7[_8];
  _10 = TempPartitionConfig->PartitionIndex;
  Power_Ip_MC_ME_ConfigureCOFB (_9, _10);

  <bb 7> :
  # DEBUG BEGIN_STMT
  CofbIndex = CofbIndex + 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _11 = TempPartitionConfig->NumberOfCofbs;
  if (CofbIndex < _11)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  CoreIndex = 0;
  goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _12 = TempPartitionConfig->ArrayPartitionCoreConfigPtr;
  _13 = (int) CoreIndex;
  _14 = *_12[_13].CoreUnderMcuControl;
  if (_14 == 1)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _15 = TempPartitionConfig->ArrayPartitionCoreConfigPtr;
  _16 = (int) CoreIndex;
  _17 = &*_15[_16];
  _18 = TempPartitionConfig->PartitionIndex;
  Power_Ip_MC_ME_ConfigureCore (_17, _18);

  <bb 12> :
  # DEBUG BEGIN_STMT
  CoreIndex = CoreIndex + 1;

  <bb 13> :
  # DEBUG BEGIN_STMT
  _19 = TempPartitionConfig->NumberOfCores;
  if (CoreIndex < _19)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  PartitionIndex = PartitionIndex + 1;

  <bb 15> :
  # DEBUG BEGIN_STMT
  if (PartitionIndex <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  return;

}


Power_Ip_MC_ME_ConfigureCore (const struct Power_Ip_MC_ME_CoreConfigType * CoreConfigPtr, uint8 PartitionIndex)
{
  uint8 CoreIndex;
  boolean TimeoutOccurred;
  uint32 TimeoutTicks;
  uint32 ElapsedTime;
  uint32 StartTime;
  uint32 CoreStatus;
  uint32 CoreConfig;

  <bb 2> :
  # DEBUG BEGIN_STMT
  CoreConfig = CoreConfigPtr->CorePconfRegValue;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutOccurred = 0;
  # DEBUG BEGIN_STMT
  CoreIndex = CoreConfigPtr->CoreIndex;
  # DEBUG BEGIN_STMT
  _1 = CoreConfigPtr->CorePconfRegValue;
  _2 = _1 & 1;
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Power_Ip_StartTimeout (&StartTime, &ElapsedTime, &TimeoutTicks, 50000);

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutTicks.7_3 = TimeoutTicks;
  TimeoutOccurred = Power_Ip_TimeoutExpired (&StartTime, &ElapsedTime, TimeoutTicks.7_3);
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.8_4 = Power_Ip_pxMC_ME;
  _5 = (int) PartitionIndex;
  _6 = (int) CoreIndex;
  CoreStatus = Power_Ip_pxMC_ME.8_4->McMePrtnArray[_5].McMePrtnCoreArray[_6].PRTN_CORE_STAT;
  # DEBUG BEGIN_STMT
  CoreStatus.9_7 = (signed int) CoreStatus;
  if (CoreStatus.9_7 >= 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (TimeoutOccurred == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  if (TimeoutOccurred != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  Power_Ip_ReportPowerErrors (0, 255);

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (TimeoutOccurred == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.10_8 = Power_Ip_pxMC_ME;
  _9 = (int) PartitionIndex;
  _10 = (int) CoreIndex;
  Power_Ip_pxMC_ME.10_8->McMePrtnArray[_9].McMePrtnCoreArray[_10].PRTN_CORE_PCONF = CoreConfig;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_TriggerCoreUpdate (PartitionIndex, CoreIndex);
  # DEBUG BEGIN_STMT
  Power_Ip_StartTimeout (&StartTime, &ElapsedTime, &TimeoutTicks, 50000);

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutTicks.11_11 = TimeoutTicks;
  TimeoutOccurred = Power_Ip_TimeoutExpired (&StartTime, &ElapsedTime, TimeoutTicks.11_11);
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.12_12 = Power_Ip_pxMC_ME;
  _13 = (int) PartitionIndex;
  _14 = (int) CoreIndex;
  CoreStatus = Power_Ip_pxMC_ME.12_12->McMePrtnArray[_13].McMePrtnCoreArray[_14].PRTN_CORE_STAT;
  # DEBUG BEGIN_STMT
  _15 = CoreStatus ^ CoreConfig;
  _16 = _15 & 1;
  if (_16 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  if (TimeoutOccurred == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (TimeoutOccurred != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  Power_Ip_ReportPowerErrors (0, 255);

  <bb 14> :
  StartTime = {CLOBBER};
  ElapsedTime = {CLOBBER};
  TimeoutTicks = {CLOBBER};
  return;

}


Power_Ip_MC_ME_ConfigureCOFB (const struct Power_Ip_MC_ME_CofbConfigType * CofbConfigPtr, uint8 PartitionIndex)
{
  uint8 CofbIndex;
  boolean TimeoutOccurred;
  uint32 TimeoutTicks;
  uint32 ElapsedTime;
  uint32 StartTime;
  uint32 PeripheralsStatus;
  uint32 PeripheralsToUpdate;
  uint32 PeripheralsConfig;

  <bb 2> :
  # DEBUG BEGIN_STMT
  PeripheralsConfig = CofbConfigPtr->CofbClkenRegValue;
  # DEBUG BEGIN_STMT
  PeripheralsToUpdate = CofbConfigPtr->CofbBlocksToUpdateMask;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutOccurred = 0;
  # DEBUG BEGIN_STMT
  CofbIndex = CofbConfigPtr->CofbIndex;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.0_1 = Power_Ip_pxMC_ME;
  _2 = (int) PartitionIndex;
  _3 = (int) CofbIndex;
  Power_Ip_pxMC_ME.0_1->McMePrtnArray[_2].PRTN_COFB_CLKEN[_3] = PeripheralsConfig;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_TriggerCofbUpdate (PartitionIndex);
  # DEBUG BEGIN_STMT
  Power_Ip_StartTimeout (&StartTime, &ElapsedTime, &TimeoutTicks, 50000);

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutTicks.1_4 = TimeoutTicks;
  TimeoutOccurred = Power_Ip_TimeoutExpired (&StartTime, &ElapsedTime, TimeoutTicks.1_4);
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.2_5 = Power_Ip_pxMC_ME;
  _6 = (int) PartitionIndex;
  _7 = (int) CofbIndex;
  PeripheralsStatus = Power_Ip_pxMC_ME.2_5->McMePrtnArray[_6].PRTN_COFB_STAT[_7];
  # DEBUG BEGIN_STMT
  _8 = PeripheralsStatus & PeripheralsToUpdate;
  if (PeripheralsConfig != _8)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  if (TimeoutOccurred == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (TimeoutOccurred != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Power_Ip_ReportPowerErrors (0, 255);

  <bb 7> :
  StartTime = {CLOBBER};
  ElapsedTime = {CLOBBER};
  TimeoutTicks = {CLOBBER};
  return;

}


Power_Ip_MC_ME_ConfigurePartitionClock (const struct Power_Ip_MC_ME_PartitionConfigType * PartitionConfigPtr)
{
  uint8 PartitionIndex;
  boolean TimeoutOccurred;
  uint32 TimeoutTicks;
  uint32 ElapsedTime;
  uint32 StartTime;
  uint32 PartitionStatus;
  uint32 PartitionTriggerMask;
  uint32 PartitionConfig;
  uint32 TempValue;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempValue = 0;
  # DEBUG BEGIN_STMT
  PartitionConfig = PartitionConfigPtr->PartitionPconfRegValue;
  # DEBUG BEGIN_STMT
  PartitionTriggerMask = PartitionConfigPtr->PartitionTriggerMask;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutOccurred = 0;
  # DEBUG BEGIN_STMT
  PartitionIndex = PartitionConfigPtr->PartitionIndex;
  # DEBUG BEGIN_STMT
  _1 = PartitionTriggerMask & 1;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.15_2 = Power_Ip_pxMC_ME;
  _3 = (int) PartitionIndex;
  TempValue = Power_Ip_pxMC_ME.15_2->McMePrtnArray[_3].PRTN_PCONF;
  # DEBUG BEGIN_STMT
  TempValue = TempValue & 4294967294;
  # DEBUG BEGIN_STMT
  _4 = PartitionConfig & 1;
  TempValue = TempValue | _4;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.16_5 = Power_Ip_pxMC_ME;
  _6 = (int) PartitionIndex;
  Power_Ip_pxMC_ME.16_5->McMePrtnArray[_6].PRTN_PCONF = TempValue;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_TriggerPartitionUpdate (1, PartitionIndex);
  # DEBUG BEGIN_STMT
  Power_Ip_StartTimeout (&StartTime, &ElapsedTime, &TimeoutTicks, 50000);

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  TimeoutTicks.17_7 = TimeoutTicks;
  TimeoutOccurred = Power_Ip_TimeoutExpired (&StartTime, &ElapsedTime, TimeoutTicks.17_7);
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.18_8 = Power_Ip_pxMC_ME;
  _9 = (int) PartitionIndex;
  PartitionStatus = Power_Ip_pxMC_ME.18_8->McMePrtnArray[_9].PRTN_STAT;
  # DEBUG BEGIN_STMT
  _10 = PartitionStatus ^ PartitionConfig;
  _11 = _10 & 1;
  if (_11 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (TimeoutOccurred == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  if (TimeoutOccurred != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  Power_Ip_ReportPowerErrors (0, 255);

  <bb 8> :
  StartTime = {CLOBBER};
  ElapsedTime = {CLOBBER};
  TimeoutTicks = {CLOBBER};
  return;

}


Power_Ip_MC_ME_TriggerCoreUpdate (uint8 PartitionIndex, uint8 CoreIndex)
{
  uint32 TempValue;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempValue = 0;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.13_1 = Power_Ip_pxMC_ME;
  _2 = (int) PartitionIndex;
  _3 = (int) CoreIndex;
  TempValue = Power_Ip_pxMC_ME.13_1->McMePrtnArray[_2].McMePrtnCoreArray[_3].PRTN_CORE_PUPD;
  # DEBUG BEGIN_STMT
  TempValue = TempValue & 4294967294;
  # DEBUG BEGIN_STMT
  TempValue = TempValue | 1;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.14_4 = Power_Ip_pxMC_ME;
  _5 = (int) PartitionIndex;
  _6 = (int) CoreIndex;
  Power_Ip_pxMC_ME.14_4->McMePrtnArray[_5].McMePrtnCoreArray[_6].PRTN_CORE_PUPD = TempValue;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_WriteControlKeys ();
  return;

}


Power_Ip_MC_ME_TriggerCofbUpdate (uint8 PartitionIndex)
{
  uint32 TempValue;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempValue = 0;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.3_1 = Power_Ip_pxMC_ME;
  _2 = (int) PartitionIndex;
  TempValue = Power_Ip_pxMC_ME.3_1->McMePrtnArray[_2].PRTN_PUPD;
  # DEBUG BEGIN_STMT
  TempValue = TempValue & 4294967294;
  # DEBUG BEGIN_STMT
  TempValue = TempValue | 1;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.4_3 = Power_Ip_pxMC_ME;
  _4 = (int) PartitionIndex;
  Power_Ip_pxMC_ME.4_3->McMePrtnArray[_4].PRTN_PUPD = TempValue;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_WriteControlKeys ();
  return;

}


Power_Ip_MC_ME_TriggerPartitionUpdate (uint32 TriggerMask, uint8 PartitionIndex)
{
  uint32 TempValue;

  <bb 2> :
  # DEBUG BEGIN_STMT
  TempValue = 0;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.19_1 = Power_Ip_pxMC_ME;
  _2 = (int) PartitionIndex;
  TempValue = Power_Ip_pxMC_ME.19_1->McMePrtnArray[_2].PRTN_PUPD;
  # DEBUG BEGIN_STMT
  _3 = ~TriggerMask;
  TempValue = TempValue & _3;
  # DEBUG BEGIN_STMT
  TempValue = TempValue | TriggerMask;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.20_4 = Power_Ip_pxMC_ME;
  _5 = (int) PartitionIndex;
  Power_Ip_pxMC_ME.20_4->McMePrtnArray[_5].PRTN_PUPD = TempValue;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_WriteControlKeys ();
  return;

}


Power_Ip_MC_ME_TriggerModeUpdate ()
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.23_1 = Power_Ip_pxMC_ME;
  Power_Ip_pxMC_ME.23_1->MODE_UPD = 1;
  # DEBUG BEGIN_STMT
  Power_Ip_MC_ME_WriteControlKeys ();
  return;

}


Power_Ip_MC_ME_WriteControlKeys ()
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.5_1 = Power_Ip_pxMC_ME;
  Power_Ip_pxMC_ME.5_1->CTL_KEY = 23280;
  # DEBUG BEGIN_STMT
  Power_Ip_pxMC_ME.6_2 = Power_Ip_pxMC_ME;
  Power_Ip_pxMC_ME.6_2->CTL_KEY = 42255;
  return;

}


