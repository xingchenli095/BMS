
Marking local functions: Crypto_LNSModuloCarry Crypto_LNSModuloSubtract2 Crypto_LNSModuloSubtract Crypto_LNSModuloShift2 Crypto_LNSModuloShift Crypto_LNBarretSubtractNumbers


Marking externally visible functions: Crypto_AL_Init Crypto_LNInversion Crypto_LNSubtractionModular Crypto_LNAdditionModular Crypto_LNAddition Crypto_LNDivByTwo Crypto_LNNumberToLEByteArray Crypto_LNLEByteArrayToNumber Crypto_LNNumberToBEByteArray Crypto_LNBEByteArrayToNumber Crypto_LNModulo Crypto_LNCompareNumbers Crypto_LNSubtraction Crypto_LNMontgomeryReduction Crypto_LNMontgomeryNormalization Crypto_LNMontgomerySetup Crypto_LNMultByTwo Crypto_LNMultiplyNumbers Crypto_LNNormalizeNumber Crypto_LNBitLengthOfNumber Crypto_LNIsValid Crypto_CommonXOR Crypto_LNModuloBarrett Crypto_CheckSkipMain Crypto_StateMachineIdle Crypto_MemCmp_Sec Crypto_MemCmp


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

Crypto_AL_AESCMAC_PrecalculateKeys/41 (Crypto_AL_AESCMAC_PrecalculateKeys) @06d0e7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Crypto_AL_Init/27 
  Calls: 
Crypto_AL_KeyElementSet/40 (Crypto_AL_KeyElementSet) @06d0e700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Crypto_AL_Init/27 
  Calls: 
Crypto_AL_Keys_Data/39 (Crypto_AL_Keys_Data) @06d1ebd0
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: Crypto_AL_Init/27 (read)Crypto_AL_Init/27 (read)Crypto_AL_Init/27 (read)
  Availability: not_available
  Varpool flags:
Crypto_Keys/38 (Crypto_Keys) @06d1eb88
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: Crypto_AL_Init/27 (read)Crypto_AL_Init/27 (write)
  Availability: not_available
  Varpool flags:
TS_MemCpy32/37 (TS_MemCpy32) @068a01c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Crypto_LNMultiplyNumbers/10 
  Calls: 
TS_MemBZero32/36 (TS_MemBZero32) @068a00e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Crypto_LNMontgomeryReduction/14 Crypto_LNMultiplyNumbers/10 
  Calls: 
Crypto_DriverObjects/35 (Crypto_DriverObjects) @06cc32d0
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: Crypto_CheckSkipMain/4 (read)
  Availability: not_available
  Varpool flags:
TS_MemCmp32/34 (TS_MemCmp32) @06cba700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: Crypto_MemCmp/1 
  Calls: 
Crypto_LNSModuloCarry/33 (Crypto_LNSModuloCarry) @06cba540
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNSModuloSubtract/31 
  Calls: 
Crypto_LNSModuloSubtract2/32 (Crypto_LNSModuloSubtract2) @06cba380
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNSModuloSubtract/31 
  Calls: 
Crypto_LNSModuloSubtract/31 (Crypto_LNSModuloSubtract) @06cba1c0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNSModuloShift/29 
  Calls: Crypto_LNSModuloCarry/33 Crypto_LNSModuloSubtract2/32 
Crypto_LNSModuloShift2/30 (Crypto_LNSModuloShift2) @06cba000
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNSModuloShift/29 
  Calls: 
Crypto_LNSModuloShift/29 (Crypto_LNSModuloShift) @06c3ce00
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNModulo/17 
  Calls: Crypto_LNSModuloSubtract/31 Crypto_LNSModuloShift2/30 
Crypto_LNBarretSubtractNumbers/28 (Crypto_LNBarretSubtractNumbers) @06c3cb60
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: Crypto_LNModuloBarrett/5 Crypto_LNModuloBarrett/5 
  Calls: Crypto_LNNormalizeNumber/9 
Crypto_AL_Init/27 (Crypto_AL_Init) @06c3c460
  Type: function definition analyzed
  Visibility: externally_visible public
  References: Crypto_Keys/38 (read)Crypto_AL_Keys_Data/39 (read)Crypto_AL_Keys_Data/39 (read)Crypto_AL_Keys_Data/39 (read)Crypto_Keys/38 (write)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_AL_AESCMAC_PrecalculateKeys/41 Crypto_AL_KeyElementSet/40 
Crypto_LNInversion/26 (Crypto_LNInversion) @06c3c2a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNModulo/17 Crypto_LNSubtractionModular/25 Crypto_LNSubtractionModular/25 Crypto_LNSubtractionModular/25 Crypto_LNSubtractionModular/25 Crypto_LNCompareNumbers/16 Crypto_LNDivByTwo/22 Crypto_LNAddition/23 Crypto_LNDivByTwo/22 Crypto_LNDivByTwo/22 Crypto_LNDivByTwo/22 Crypto_LNAddition/23 Crypto_LNDivByTwo/22 Crypto_LNDivByTwo/22 
Crypto_LNSubtractionModular/25 (Crypto_LNSubtractionModular) @06c3c0e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 
  Calls: Crypto_LNNormalizeNumber/9 Crypto_LNAddition/23 
Crypto_LNAdditionModular/24 (Crypto_LNAdditionModular) @06c30ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNNormalizeNumber/9 Crypto_LNCompareNumbers/16 Crypto_LNAddition/23 
Crypto_LNAddition/23 (Crypto_LNAddition) @06c30d20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNSubtractionModular/25 Crypto_LNAdditionModular/24 
  Calls: 
Crypto_LNDivByTwo/22 (Crypto_LNDivByTwo) @06c30b60
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 Crypto_LNInversion/26 
  Calls: Crypto_LNNormalizeNumber/9 
Crypto_LNNumberToLEByteArray/21 (Crypto_LNNumberToLEByteArray) @06c309a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_LNLEByteArrayToNumber/20 (Crypto_LNLEByteArrayToNumber) @06c307e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNNormalizeNumber/9 
Crypto_LNNumberToBEByteArray/19 (Crypto_LNNumberToBEByteArray) @06c30380
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_LNBEByteArrayToNumber/18 (Crypto_LNBEByteArrayToNumber) @06c301c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNNormalizeNumber/9 
Crypto_LNModulo/17 (Crypto_LNModulo) @06c23d20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNInversion/26 
  Calls: Crypto_LNNormalizeNumber/9 Crypto_LNNormalizeNumber/9 Crypto_LNSModuloShift/29 Crypto_LNBitLengthOfNumber/8 Crypto_LNBitLengthOfNumber/8 
Crypto_LNCompareNumbers/16 (Crypto_LNCompareNumbers) @06c23b60
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNInversion/26 Crypto_LNAdditionModular/24 Crypto_LNMontgomeryReduction/14 Crypto_LNMontgomeryNormalization/13 Crypto_LNModuloBarrett/5 
  Calls: 
Crypto_LNSubtraction/15 (Crypto_LNSubtraction) @06c239a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNMontgomeryReduction/14 Crypto_LNMontgomeryNormalization/13 
  Calls: Crypto_LNNormalizeNumber/9 
Crypto_LNMontgomeryReduction/14 (Crypto_LNMontgomeryReduction) @06c237e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: Crypto_MontgomeryReductionC/0 (addr)Crypto_MontgomeryReductionC/0 (write)Crypto_MontgomeryReductionC/0 (read)Crypto_MontgomeryReductionC/0 (addr)Crypto_MontgomeryReductionC/0 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNSubtraction/15 Crypto_LNCompareNumbers/16 Crypto_LNNormalizeNumber/9 TS_MemBZero32/36 
Crypto_LNMontgomeryNormalization/13 (Crypto_LNMontgomeryNormalization) @06c23540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNSubtraction/15 Crypto_LNCompareNumbers/16 Crypto_LNMultByTwo/11 Crypto_LNBitLengthOfNumber/8 
Crypto_LNMontgomerySetup/12 (Crypto_LNMontgomerySetup) @06c23380
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_LNMultByTwo/11 (Crypto_LNMultByTwo) @06c231c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNMontgomeryNormalization/13 
  Calls: 
Crypto_LNMultiplyNumbers/10 (Crypto_LNMultiplyNumbers) @06c23000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNModuloBarrett/5 Crypto_LNModuloBarrett/5 
  Calls: TS_MemCpy32/37 Crypto_LNNormalizeNumber/9 TS_MemBZero32/36 
Crypto_LNNormalizeNumber/9 (Crypto_LNNormalizeNumber) @06c06e00
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNSubtractionModular/25 Crypto_LNAdditionModular/24 Crypto_LNDivByTwo/22 Crypto_LNLEByteArrayToNumber/20 Crypto_LNBEByteArrayToNumber/18 Crypto_LNModulo/17 Crypto_LNModulo/17 Crypto_LNSubtraction/15 Crypto_LNMontgomeryReduction/14 Crypto_LNMultiplyNumbers/10 Crypto_LNBarretSubtractNumbers/28 
  Calls: 
Crypto_LNBitLengthOfNumber/8 (Crypto_LNBitLengthOfNumber) @06c06c40
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: Crypto_LNModulo/17 Crypto_LNModulo/17 Crypto_LNMontgomeryNormalization/13 
  Calls: 
Crypto_LNIsValid/7 (Crypto_LNIsValid) @06c06a80
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_CommonXOR/6 (Crypto_CommonXOR) @06c068c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_LNModuloBarrett/5 (Crypto_LNModuloBarrett) @06c06700
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: Crypto_LNCompareNumbers/16 Crypto_LNBarretSubtractNumbers/28 Crypto_LNBarretSubtractNumbers/28 Crypto_LNMultiplyNumbers/10 Crypto_LNMultiplyNumbers/10 
Crypto_CheckSkipMain/4 (Crypto_CheckSkipMain) @06c06540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: Crypto_DriverObjects/35 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_StateMachineIdle/3 (Crypto_StateMachineIdle) @06c06380
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_MemCmp_Sec/2 (Crypto_MemCmp_Sec) @06c061c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
Crypto_MemCmp/1 (Crypto_MemCmp) @06c06000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: TS_MemCmp32/34 
Crypto_MontgomeryReductionC/0 (Crypto_MontgomeryReductionC) @06be80d8
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: Crypto_LNMontgomeryReduction/14 (addr)Crypto_LNMontgomeryReduction/14 (write)Crypto_LNMontgomeryReduction/14 (read)Crypto_LNMontgomeryReduction/14 (addr)Crypto_LNMontgomeryReduction/14 (addr)
  Availability: available
  Varpool flags: initialized
Crypto_LNSModuloCarry (Crypto_LNWordType * Number, struct Crypto_LNCtxType * CtxPtr)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = CtxPtr->Carry;
  _2 = CtxPtr->WordOfShiftedMod;
  _3 = _1 + _2;
  CtxPtr->Carry = _3;
  # DEBUG BEGIN_STMT
  _4 = CtxPtr->PosInNum;
  _5 = _4 * 4;
  _6 = Number + _5;
  _7 = *_6;
  _8 = CtxPtr->Carry;
  _9 = CtxPtr->PosInNum;
  _10 = _9 * 4;
  _11 = Number + _10;
  _12 = _7 - _8;
  *_11 = _12;
  # DEBUG BEGIN_STMT
  CtxPtr->Carry = 0;
  return;

}


Crypto_LNSModuloSubtract2 (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  uint8 TempCarry;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  goto <bb 11>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  TempCarry = 0;
  # DEBUG BEGIN_STMT
  _1 = CtxPtr->WordOfShiftedMod;
  _2 = CtxPtr->PosInMod;
  _3 = _2 * 4;
  _4 = Modulus + _3;
  _5 = *_4;
  _6 = CtxPtr->ShiftBits;
  _7 = (int) _6;
  _8 = _5 << _7;
  _9 = _1 | _8;
  CtxPtr->WordOfShiftedMod = _9;
  # DEBUG BEGIN_STMT
  _10 = CtxPtr->WordOfShiftedMod;
  _11 = CtxPtr->PosInNum;
  _12 = _11 * 4;
  _13 = Number + _12;
  _14 = *_13;
  if (_10 >= _14)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _15 = CtxPtr->WordOfShiftedMod;
  _16 = CtxPtr->PosInNum;
  _17 = _16 * 4;
  _18 = Number + _17;
  _19 = *_18;
  if (_15 > _19)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _20 = CtxPtr->Carry;
  if (_20 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  TempCarry = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _21 = CtxPtr->PosInNum;
  _22 = _21 * 4;
  _23 = Number + _22;
  _24 = *_23;
  _25 = CtxPtr->WordOfShiftedMod;
  _26 = CtxPtr->PosInNum;
  _27 = _26 * 4;
  _28 = Number + _27;
  _29 = _24 - _25;
  *_28 = _29;
  # DEBUG BEGIN_STMT
  _30 = CtxPtr->PosInNum;
  _31 = _30 * 4;
  _32 = Number + _31;
  _33 = *_32;
  _34 = CtxPtr->Carry;
  _35 = CtxPtr->PosInNum;
  _36 = _35 * 4;
  _37 = Number + _36;
  _38 = _33 - _34;
  *_37 = _38;
  # DEBUG BEGIN_STMT
  _39 = (long unsigned int) TempCarry;
  CtxPtr->Carry = _39;
  # DEBUG BEGIN_STMT
  _40 = CtxPtr->ShiftBits;
  if (_40 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  CtxPtr->WordOfShiftedMod = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _41 = CtxPtr->PosInMod;
  _42 = _41 * 4;
  _43 = Modulus + _42;
  _44 = *_43;
  _45 = CtxPtr->ShiftBits;
  _46 = 32 - _45;
  _47 = (int) _46;
  _48 = _44 >> _47;
  CtxPtr->WordOfShiftedMod = _48;

  <bb 10> :
  # DEBUG BEGIN_STMT
  _49 = CtxPtr->PosInNum;
  _50 = _49 + 1;
  CtxPtr->PosInNum = _50;
  # DEBUG BEGIN_STMT
  _51 = CtxPtr->PosInMod;
  _52 = _51 + 1;
  CtxPtr->PosInMod = _52;

  <bb 11> :
  # DEBUG BEGIN_STMT
  _53 = CtxPtr->PosInMod;
  _54 = *Modulus;
  if (_53 <= _54)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  return;

}


Crypto_LNSModuloSubtract (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = CtxPtr->CmpNumMod;
  if (_1 != 4)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  CtxPtr->WordOfShiftedMod = 0;
  # DEBUG BEGIN_STMT
  CtxPtr->Carry = 0;
  # DEBUG BEGIN_STMT
  _2 = CtxPtr->ShiftWords;
  _3 = _2 + 1;
  CtxPtr->PosInNum = _3;
  # DEBUG BEGIN_STMT
  CtxPtr->PosInMod = 1;
  # DEBUG BEGIN_STMT
  Crypto_LNSModuloSubtract2 (Number, Modulus, CtxPtr);
  # DEBUG BEGIN_STMT
  Crypto_LNSModuloCarry (Number, CtxPtr);

  <bb 4> :
  return;

}


Crypto_LNSModuloShift2 (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  Crypto_LNWordType WordOfNumber;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = CtxPtr->PosInMod;
  _2 = *Modulus;
  if (_1 <= _2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _3 = CtxPtr->PosInMod;
  _4 = _3 * 4;
  _5 = Modulus + _4;
  _6 = *_5;
  _7 = CtxPtr->ShiftBits;
  _8 = (int) _7;
  _9 = _6 << _8;
  CtxPtr->WordOfShiftedMod = _9;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  CtxPtr->WordOfShiftedMod = 0;

  <bb 5> :
  # DEBUG BEGIN_STMT
  _10 = CtxPtr->ShiftBits;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _11 = CtxPtr->PosInMod;
  if (_11 > 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _12 = CtxPtr->WordOfShiftedMod;
  _13 = CtxPtr->PosInMod;
  _14 = _13 + 1073741823;
  _15 = _14 * 4;
  _16 = Modulus + _15;
  _17 = *_16;
  _18 = CtxPtr->ShiftBits;
  _19 = 32 - _18;
  _20 = (int) _19;
  _21 = _17 >> _20;
  _22 = _12 | _21;
  CtxPtr->WordOfShiftedMod = _22;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _23 = CtxPtr->PosInNum;
  _24 = *Number;
  if (_23 > _24)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  WordOfNumber = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _25 = CtxPtr->PosInNum;
  _26 = _25 * 4;
  _27 = Number + _26;
  WordOfNumber = *_27;

  <bb 11> :
  # DEBUG BEGIN_STMT
  _28 = CtxPtr->WordOfShiftedMod;
  if (WordOfNumber == _28)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  CtxPtr->CmpNumMod = 2;
  goto <bb 16>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _29 = CtxPtr->WordOfShiftedMod;
  if (WordOfNumber < _29)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  CtxPtr->CmpNumMod = 4;
  goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  CtxPtr->CmpNumMod = 5;

  <bb 16> :
  # DEBUG BEGIN_STMT
  _30 = CtxPtr->PosInMod;
  _31 = _30 + 4294967295;
  CtxPtr->PosInMod = _31;
  # DEBUG BEGIN_STMT
  _32 = CtxPtr->PosInNum;
  _33 = _32 + 4294967295;
  CtxPtr->PosInNum = _33;
  # DEBUG BEGIN_STMT
  _34 = CtxPtr->CmpNumMod;
  if (_34 == 2)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _35 = CtxPtr->PosInMod;
  if (_35 != 0)
    goto <bb 2>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  return;

}


Crypto_LNSModuloShift (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = CtxPtr->LengthDifference;
  _2 = _1 + 4294967295;
  CtxPtr->LengthDifference = _2;
  # DEBUG BEGIN_STMT
  _3 = CtxPtr->LengthDifference;
  _4 = _3 >> 5;
  CtxPtr->ShiftWords = _4;
  # DEBUG BEGIN_STMT
  _5 = CtxPtr->LengthDifference;
  _6 = (unsigned char) _5;
  _7 = _6 & 31;
  CtxPtr->ShiftBits = _7;
  # DEBUG BEGIN_STMT
  _8 = *Modulus;
  _9 = _8 + 1;
  CtxPtr->PosInMod = _9;
  # DEBUG BEGIN_STMT
  _10 = CtxPtr->PosInMod;
  _11 = CtxPtr->ShiftWords;
  _12 = _10 + _11;
  CtxPtr->PosInNum = _12;
  # DEBUG BEGIN_STMT
  Crypto_LNSModuloShift2 (Number, Modulus, CtxPtr);
  # DEBUG BEGIN_STMT
  Crypto_LNSModuloSubtract (Number, Modulus, CtxPtr);
  return;

}


Crypto_LNBarretSubtractNumbers (Crypto_LNWordType * Result, const Crypto_LNWordType * Minuend, const Crypto_LNWordType * Subtrahend, Crypto_LNWordType CutOff)
{
  Crypto_LNWordType UpperDifference;
  Crypto_LNWordType LowerDifference;
  Crypto_LNWordType UpperDifference;
  Crypto_LNWordType LowerDifference;
  Crypto_LNWordType Borrow;
  Crypto_LNWordType LoopCount;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Borrow = 0;
  # DEBUG BEGIN_STMT
  LoopCount = 1;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = LoopCount * 4;
  _2 = Minuend + _1;
  _3 = *_2;
  _4 = _3 & 65535;
  _5 = LoopCount * 4;
  _6 = Subtrahend + _5;
  _7 = *_6;
  _8 = _7 & 65535;
  _9 = _4 - _8;
  LowerDifference = _9 - Borrow;
  # DEBUG BEGIN_STMT
  _10 = LowerDifference >> 16;
  Borrow = _10 & 1;
  # DEBUG BEGIN_STMT
  LowerDifference = LowerDifference & 65535;
  # DEBUG BEGIN_STMT
  _11 = LoopCount * 4;
  _12 = Minuend + _11;
  _13 = *_12;
  _14 = _13 >> 16;
  _15 = LoopCount * 4;
  _16 = Subtrahend + _15;
  _17 = *_16;
  _18 = _17 >> 16;
  _19 = _14 - _18;
  UpperDifference = _19 - Borrow;
  # DEBUG BEGIN_STMT
  _20 = UpperDifference >> 16;
  Borrow = _20 & 1;
  # DEBUG BEGIN_STMT
  UpperDifference = UpperDifference & 65535;
  # DEBUG BEGIN_STMT
  _21 = UpperDifference << 16;
  _22 = LoopCount * 4;
  _23 = Result + _22;
  _24 = LowerDifference | _21;
  *_23 = _24;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _25 = *Subtrahend;
  if (LoopCount <= _25)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (LoopCount <= CutOff)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _26 = LoopCount * 4;
  _27 = Minuend + _26;
  _28 = *_27;
  _29 = _28 & 65535;
  LowerDifference = _29 - Borrow;
  # DEBUG BEGIN_STMT
  _30 = LowerDifference >> 16;
  Borrow = _30 & 1;
  # DEBUG BEGIN_STMT
  LowerDifference = LowerDifference & 65535;
  # DEBUG BEGIN_STMT
  _31 = LoopCount * 4;
  _32 = Minuend + _31;
  _33 = *_32;
  _34 = _33 >> 16;
  UpperDifference = _34 - Borrow;
  # DEBUG BEGIN_STMT
  _35 = UpperDifference >> 16;
  Borrow = _35 & 1;
  # DEBUG BEGIN_STMT
  UpperDifference = UpperDifference & 65535;
  # DEBUG BEGIN_STMT
  _36 = UpperDifference << 16;
  _37 = LoopCount * 4;
  _38 = Result + _37;
  _39 = LowerDifference | _36;
  *_38 = _39;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _40 = *Minuend;
  if (LoopCount <= _40)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _41 = LoopCount + 4294967295;
  *Result = _41;
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Result);
  return;

}


Crypto_AL_Init ()
{
  uint32 KeyElementId;
  uint32 KeyElementIndex;
  uint32 CryptoKeyId;

  <bb 2> :
  # DEBUG BEGIN_STMT
  CryptoKeyId = 0;
  # DEBUG BEGIN_STMT
  KeyElementIndex = 0;
  # DEBUG BEGIN_STMT
  KeyElementId = 0;
  # DEBUG BEGIN_STMT
  CryptoKeyId = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  KeyElementIndex = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _1 = Crypto_Keys[CryptoKeyId].KeyType;
  _2 = KeyElementIndex * 4;
  _3 = _1 + _2;
  _4 = *_3;
  KeyElementId = _4->Id;
  # DEBUG BEGIN_STMT
  _5 = Crypto_AL_Keys_Data[CryptoKeyId].KeyData;
  _6 = KeyElementIndex * 12;
  _7 = _5 + _6;
  _8 = _7->RfKeyElemDataInit;
  _9 = Crypto_AL_Keys_Data[CryptoKeyId].KeyData;
  _10 = KeyElementIndex * 12;
  _11 = _9 + _10;
  _12 = _11->RfKeyElemDataSize;
  Crypto_AL_KeyElementSet (CryptoKeyId, KeyElementId, _8, _12);
  # DEBUG BEGIN_STMT
  KeyElementIndex = KeyElementIndex + 1;

  <bb 5> :
  # DEBUG BEGIN_STMT
  _13 = Crypto_AL_Keys_Data[CryptoKeyId].NumKeyData;
  if (KeyElementIndex < _13)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Crypto_AL_AESCMAC_PrecalculateKeys (CryptoKeyId);
  # DEBUG BEGIN_STMT
  Crypto_Keys[CryptoKeyId].KeyState = 1;
  # DEBUG BEGIN_STMT
  CryptoKeyId = CryptoKeyId + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (CryptoKeyId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  return;

}


Crypto_LNInversion (Crypto_LNWordType * InvValue, const Crypto_LNWordType * Value, Crypto_LNWordType * Tmp1Value, Crypto_LNWordType * Tmp2Value, Crypto_LNWordType * Tmp3Value, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  Crypto_ReturnType CompNumRes;
  Crypto_LNWordType i;
  Crypto_LNWordType AddResult;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = i * 4;
  _2 = Value + _1;
  _3 = i * 4;
  _4 = Tmp1Value + _3;
  _5 = *_2;
  *_4 = _5;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _6 = *Value;
  if (i <= _6)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _7 = i * 4;
  _8 = Modulus + _7;
  _9 = i * 4;
  _10 = Tmp2Value + _9;
  _11 = *_8;
  *_10 = _11;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _12 = *Modulus;
  if (i <= _12)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  *Tmp3Value = 1;
  # DEBUG BEGIN_STMT
  _13 = Tmp3Value + 4;
  *_13 = 1;
  # DEBUG BEGIN_STMT
  *InvValue = 0;
  # DEBUG BEGIN_STMT
  _14 = InvValue + 4;
  *_14 = 0;
  # DEBUG BEGIN_STMT
  goto <bb 21>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (Tmp1Value, 0);
  # DEBUG BEGIN_STMT
  _15 = Tmp3Value + 4;
  _16 = *_15;
  _17 = _16 & 1;
  if (_17 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (Tmp3Value, 0);
  goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _18 = Crypto_LNAddition (Tmp3Value, Tmp3Value, Modulus);
  AddResult = (Crypto_LNWordType) _18;
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (Tmp3Value, AddResult);

  <bb 12> :
  # DEBUG BEGIN_STMT
  _19 = Tmp1Value + 4;
  _20 = *_19;
  _21 = _20 & 1;
  if (_21 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (Tmp2Value, 0);
  # DEBUG BEGIN_STMT
  _22 = InvValue + 4;
  _23 = *_22;
  _24 = _23 & 1;
  if (_24 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (InvValue, 0);
  goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  _25 = Crypto_LNAddition (InvValue, InvValue, Modulus);
  AddResult = (Crypto_LNWordType) _25;
  # DEBUG BEGIN_STMT
  Crypto_LNDivByTwo (InvValue, AddResult);

  <bb 16> :
  # DEBUG BEGIN_STMT
  _26 = Tmp2Value + 4;
  _27 = *_26;
  _28 = _27 & 1;
  if (_28 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  CompNumRes = Crypto_LNCompareNumbers (Tmp1Value, Tmp2Value);
  # DEBUG BEGIN_STMT
  if (CompNumRes == 5)
    goto <bb 19>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  if (CompNumRes == 2)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  Crypto_LNSubtractionModular (Tmp1Value, Tmp1Value, Tmp2Value, Modulus);
  # DEBUG BEGIN_STMT
  Crypto_LNSubtractionModular (Tmp3Value, Tmp3Value, InvValue, Modulus);
  goto <bb 21>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  Crypto_LNSubtractionModular (Tmp2Value, Tmp2Value, Tmp1Value, Modulus);
  # DEBUG BEGIN_STMT
  Crypto_LNSubtractionModular (InvValue, InvValue, Tmp3Value, Modulus);

  <bb 21> :
  # DEBUG BEGIN_STMT
  _29 = *Tmp1Value;
  if (_29 != 1)
    goto <bb 23>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  _30 = Tmp1Value + 4;
  _31 = *_30;
  if (_31 != 1)
    goto <bb 23>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 23> :
  _32 = *Tmp2Value;
  if (_32 != 1)
    goto <bb 25>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _33 = Tmp2Value + 4;
  _34 = *_33;
  if (_34 != 1)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _35 = *Tmp1Value;
  if (_35 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  # DEBUG BEGIN_STMT
  _36 = *Tmp1Value;
  if (_36 == 1)
    goto <bb 27>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 27> :
  _37 = Tmp1Value + 4;
  _38 = *_37;
  if (_38 == 1)
    goto <bb 28>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 28> :
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 30>; [INV]

  <bb 29> :
  # DEBUG BEGIN_STMT
  _39 = i * 4;
  _40 = Tmp3Value + _39;
  _41 = i * 4;
  _42 = InvValue + _41;
  _43 = *_40;
  *_42 = _43;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 30> :
  # DEBUG BEGIN_STMT
  _44 = *Tmp3Value;
  if (i <= _44)
    goto <bb 29>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 31> :
  # DEBUG BEGIN_STMT
  Crypto_LNModulo (InvValue, Modulus, CtxPtr);
  return;

}


Crypto_LNSubtractionModular (Crypto_LNWordType * Difference, const Crypto_LNWordType * Minuend, const Crypto_LNWordType * Subtrahend, const Crypto_LNWordType * Modulus)
{
  Crypto_LNWordType Tmp2;
  Crypto_LNWordType Tmp;
  uint8 Borrow;
  Crypto_LNWordType i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Borrow = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 1;
  goto <bb 15>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = *Minuend;
  if (i > _1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  Tmp = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _2 = i * 4;
  _3 = Minuend + _2;
  Tmp = *_3;

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = *Subtrahend;
  if (i > _4)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  Tmp2 = 0;
  goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _5 = i * 4;
  _6 = Subtrahend + _5;
  Tmp2 = *_6;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _7 = Tmp - Tmp2;
  _8 = (long unsigned int) Borrow;
  _9 = i * 4;
  _10 = Difference + _9;
  _11 = _7 - _8;
  *_10 = _11;
  # DEBUG BEGIN_STMT
  _12 = i * 4;
  _13 = Difference + _12;
  _14 = *_13;
  if (Tmp <= _14)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (Tmp2 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (Borrow != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  Borrow = 1;
  goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  Borrow = 0;

  <bb 14> :
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 15> :
  # DEBUG BEGIN_STMT
  _15 = *Modulus;
  if (i <= _15)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  _16 = *Modulus;
  *Difference = _16;
  # DEBUG BEGIN_STMT
  if (Borrow == 1)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Borrow = Crypto_LNAddition (Difference, Difference, Modulus);
  # DEBUG BEGIN_STMT
  if (Borrow == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Difference);
  return;

}


Crypto_LNAdditionModular (Crypto_LNWordType * Sum, const Crypto_LNWordType * Addend1, const Crypto_LNWordType * Addend2, const Crypto_LNWordType * Modulus)
{
  uint8 Borrow;
  uint8 Carry;
  Crypto_LNWordType Tmp;
  Crypto_LNWordType i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Carry = 0;
  # DEBUG BEGIN_STMT
  Borrow = 0;
  # DEBUG BEGIN_STMT
  Carry = Crypto_LNAddition (Sum, Addend1, Addend2);
  # DEBUG BEGIN_STMT
  _1 = *Sum;
  i = _1 + 1;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _2 = i * 4;
  _3 = Sum + _2;
  *_3 = 0;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _4 = *Modulus;
  if (i <= _4)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = *Sum;
  _6 = *Modulus;
  if (_5 < _6)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (Carry == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _7 = *Sum;
  _8 = _7 + 1;
  *Sum = _8;
  # DEBUG BEGIN_STMT
  _9 = *Sum;
  _10 = _9 * 4;
  _11 = Sum + _10;
  *_11 = 1;
  goto <bb 18>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _12 = Crypto_LNCompareNumbers (Sum, Modulus);
  if (_12 != 4)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  if (Carry == 1)
    goto <bb 10>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  i = 1;
  goto <bb 17>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _13 = i * 4;
  _14 = Sum + _13;
  Tmp = *_14;
  # DEBUG BEGIN_STMT
  _15 = i * 4;
  _16 = Sum + _15;
  _17 = *_16;
  _18 = i * 4;
  _19 = Modulus + _18;
  _20 = *_19;
  _21 = _17 - _20;
  _22 = (long unsigned int) Borrow;
  _23 = i * 4;
  _24 = Sum + _23;
  _25 = _21 - _22;
  *_24 = _25;
  # DEBUG BEGIN_STMT
  _26 = i * 4;
  _27 = Sum + _26;
  _28 = *_27;
  if (Tmp <= _28)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  _29 = i * 4;
  _30 = Modulus + _29;
  _31 = *_30;
  if (_31 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  if (Borrow != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  Borrow = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  Borrow = 0;

  <bb 16> :
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 17> :
  # DEBUG BEGIN_STMT
  _32 = *Modulus;
  if (i <= _32)
    goto <bb 11>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Sum);
  return;

}


Crypto_LNAddition (Crypto_LNWordType * Sum, const Crypto_LNWordType * Addend1, const Crypto_LNWordType * Addend2)
{
  Crypto_LNWordType Carry;
  Crypto_LNWordType MaxLength;
  Crypto_LNWordType MinLength;
  Crypto_LNWordType LoopCount;
  Crypto_LNDoubleWordType TempSum;
  const Crypto_LNWordType * LargestOperand;
  uint8 D.6643;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Carry = 0;
  # DEBUG BEGIN_STMT
  _1 = *Addend1;
  _2 = *Addend2;
  if (_1 > _2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  MinLength = *Addend2;
  # DEBUG BEGIN_STMT
  MaxLength = *Addend1;
  # DEBUG BEGIN_STMT
  LargestOperand = Addend1;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  MinLength = *Addend1;
  # DEBUG BEGIN_STMT
  MaxLength = *Addend2;
  # DEBUG BEGIN_STMT
  LargestOperand = Addend2;

  <bb 5> :
  # DEBUG BEGIN_STMT
  LoopCount = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _3 = LoopCount * 4;
  _4 = Addend1 + _3;
  _5 = *_4;
  _6 = (long long unsigned int) _5;
  _7 = LoopCount * 4;
  _8 = Addend2 + _7;
  _9 = *_8;
  _10 = (long long unsigned int) _9;
  _11 = _6 + _10;
  _12 = (long long unsigned int) Carry;
  TempSum = _11 + _12;
  # DEBUG BEGIN_STMT
  _13 = LoopCount * 4;
  _14 = Sum + _13;
  _15 = (long unsigned int) TempSum;
  *_14 = _15;
  # DEBUG BEGIN_STMT
  _16 = TempSum >> 32;
  Carry = (Crypto_LNWordType) _16;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (LoopCount <= MinLength)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _17 = LoopCount * 4;
  _18 = LargestOperand + _17;
  _19 = *_18;
  _20 = (long long unsigned int) _19;
  _21 = (long long unsigned int) Carry;
  TempSum = _20 + _21;
  # DEBUG BEGIN_STMT
  _22 = LoopCount * 4;
  _23 = Sum + _22;
  _24 = (long unsigned int) TempSum;
  *_23 = _24;
  # DEBUG BEGIN_STMT
  _25 = TempSum >> 32;
  Carry = (Crypto_LNWordType) _25;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (LoopCount <= MaxLength)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  *Sum = MaxLength;
  # DEBUG BEGIN_STMT
  D.6643 = (uint8) Carry;
  return D.6643;

}


Crypto_LNDivByTwo (Crypto_LNWordType * Value, Crypto_LNWordType Overflow)
{
  Crypto_LNWordType DiffTmpVal2;
  Crypto_LNWordType DiffTmpVal1;
  Crypto_LNWordType i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  DiffTmpVal2 = Overflow;
  # DEBUG BEGIN_STMT
  i = *Value;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = i * 4;
  _2 = Value + _1;
  _3 = *_2;
  DiffTmpVal1 = _3 & 1;
  # DEBUG BEGIN_STMT
  _4 = i * 4;
  _5 = Value + _4;
  _6 = *_5;
  _7 = i * 4;
  _8 = Value + _7;
  _9 = _6 >> 1;
  *_8 = _9;
  # DEBUG BEGIN_STMT
  _10 = i * 4;
  _11 = Value + _10;
  _12 = *_11;
  _13 = DiffTmpVal2 << 31;
  _14 = i * 4;
  _15 = Value + _14;
  _16 = _12 | _13;
  *_15 = _16;
  # DEBUG BEGIN_STMT
  DiffTmpVal2 = DiffTmpVal1;
  # DEBUG BEGIN_STMT
  i = i + 4294967295;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (i != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Value);
  return;

}


Crypto_LNNumberToLEByteArray (const Crypto_LNWordType * Number, uint8 * Array, uint32 * ArrayLengthPtr)
{
  Std_ReturnType RetVal;
  Crypto_LNWordType ArrayPos;
  Crypto_LNWordType WordPos;
  Crypto_LNWordType NumberPos;
  Std_ReturnType D.6638;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  RetVal = 0;
  # DEBUG BEGIN_STMT
  _1 = *ArrayLengthPtr;
  _2 = _1 / 4;
  _3 = *Number;
  if (_2 < _3)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  NumberPos = 1;
  goto <bb 9>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  ArrayPos = NumberPos;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos + 4294967295;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos * 4;
  # DEBUG BEGIN_STMT
  WordPos = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = NumberPos * 4;
  _5 = Number + _4;
  _6 = *_5;
  _7 = WordPos << 3;
  _8 = _6 >> _7;
  _9 = Array + ArrayPos;
  _10 = (unsigned char) _8;
  *_9 = _10;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos + 1;
  # DEBUG BEGIN_STMT
  WordPos = WordPos + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (WordPos <= 3)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  NumberPos = NumberPos + 1;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = *Number;
  if (NumberPos <= _11)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _12 = *Number;
  _13 = (short unsigned int) _12;
  _14 = _13 * 4;
  _15 = (long unsigned int) _14;
  *ArrayLengthPtr = _15;

  <bb 11> :
  # DEBUG BEGIN_STMT
  D.6638 = RetVal;
  return D.6638;

}


Crypto_LNLEByteArrayToNumber (const uint8 * Array, uint32 ArrayLength, Crypto_LNWordType * Number, Crypto_LNWordType NumberLength)
{
  Std_ReturnType RetVal;
  uint16 ArrayPos;
  Crypto_LNWordType WordPos;
  Crypto_LNWordType NumberPos;
  Std_ReturnType D.6633;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  RetVal = 0;
  # DEBUG BEGIN_STMT
  if (ArrayLength != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = ArrayLength + 4294967295;
  _2 = _1 / 4;
  _3 = _2 + 2;
  if (NumberLength < _3)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 17>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  NumberPos = 1;
  goto <bb 12>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = NumberPos * 4;
  _5 = Number + _4;
  *_5 = 0;
  # DEBUG BEGIN_STMT
  WordPos = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  ArrayPos = 4;
  # DEBUG BEGIN_STMT
  _6 = (short unsigned int) NumberPos;
  _7 = _6 + 65535;
  ArrayPos = ArrayPos * _7;
  # DEBUG BEGIN_STMT
  _8 = (short unsigned int) WordPos;
  ArrayPos = ArrayPos + _8;
  # DEBUG BEGIN_STMT
  _9 = (long unsigned int) ArrayPos;
  if (ArrayLength > _9)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _10 = NumberPos * 4;
  _11 = Number + _10;
  _12 = *_11;
  _13 = (sizetype) ArrayPos;
  _14 = Array + _13;
  _15 = *_14;
  _16 = (long unsigned int) _15;
  _17 = WordPos << 3;
  _18 = _16 << _17;
  _19 = NumberPos * 4;
  _20 = Number + _19;
  _21 = _12 | _18;
  *_20 = _21;

  <bb 9> :
  # DEBUG BEGIN_STMT
  WordPos = WordPos + 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (WordPos <= 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  NumberPos = NumberPos + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  _22 = ArrayLength + 4294967295;
  _23 = _22 / 4;
  _24 = _23 + 1;
  if (NumberPos <= _24)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _25 = ArrayLength + 4294967295;
  _26 = _25 / 4;
  _27 = _26 + 1;
  *Number = _27;
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Number);
  goto <bb 17>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  if (NumberLength == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  *Number = 0;

  <bb 17> :
  # DEBUG BEGIN_STMT
  D.6633 = RetVal;
  return D.6633;

}


Crypto_LNNumberToBEByteArray (const Crypto_LNWordType * Number, uint8 * Array, uint32 * ArrayLengthPtr)
{
  Std_ReturnType RetVal;
  Crypto_LNWordType ArrayPos;
  Crypto_LNWordType WordPos;
  Crypto_LNWordType NumberPos;
  Std_ReturnType D.6620;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  RetVal = 0;
  # DEBUG BEGIN_STMT
  _1 = *ArrayLengthPtr;
  _2 = _1 / 4;
  _3 = *Number;
  if (_2 < _3)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 11>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  NumberPos = 1;
  goto <bb 9>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  ArrayPos = *Number;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos - NumberPos;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos + 1;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos * 4;
  # DEBUG BEGIN_STMT
  WordPos = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos + 4294967295;
  # DEBUG BEGIN_STMT
  _4 = NumberPos * 4;
  _5 = Number + _4;
  _6 = *_5;
  _7 = (unsigned char) WordPos;
  _8 = _7 << 3;
  _9 = (int) _8;
  _10 = _6 >> _9;
  _11 = Array + ArrayPos;
  _12 = (unsigned char) _10;
  *_11 = _12;
  # DEBUG BEGIN_STMT
  WordPos = WordPos + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (WordPos <= 3)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  NumberPos = NumberPos + 1;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _13 = *Number;
  if (NumberPos <= _13)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _14 = *Number;
  _15 = (short unsigned int) _14;
  _16 = _15 * 4;
  _17 = (long unsigned int) _16;
  *ArrayLengthPtr = _17;

  <bb 11> :
  # DEBUG BEGIN_STMT
  D.6620 = RetVal;
  return D.6620;

}


Crypto_LNBEByteArrayToNumber (const uint8 * Array, uint32 ArrayLength, Crypto_LNWordType * Number, Crypto_LNWordType NumberLength)
{
  Std_ReturnType RetVal;
  uint32 ArrayPos;
  Crypto_LNWordType WordPos;
  Crypto_LNWordType NumberPos;
  Std_ReturnType D.6615;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  RetVal = 1;
  # DEBUG BEGIN_STMT
  if (ArrayLength != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = ArrayLength + 4294967295;
  _2 = _1 / 4;
  _3 = _2 + 2;
  if (NumberLength < _3)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 17>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  NumberPos = 1;
  goto <bb 12>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = NumberPos * 4;
  _5 = Number + _4;
  *_5 = 0;
  # DEBUG BEGIN_STMT
  WordPos = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  ArrayPos = 4;
  # DEBUG BEGIN_STMT
  _6 = NumberPos + 4294967295;
  ArrayPos = ArrayPos * _6;
  # DEBUG BEGIN_STMT
  ArrayPos = ArrayPos + WordPos;
  # DEBUG BEGIN_STMT
  _7 = ArrayLength - ArrayPos;
  ArrayPos = _7 + 4294967295;
  # DEBUG BEGIN_STMT
  if (ArrayPos < ArrayLength)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _8 = NumberPos * 4;
  _9 = Number + _8;
  _10 = *_9;
  _11 = Array + ArrayPos;
  _12 = *_11;
  _13 = (long unsigned int) _12;
  _14 = WordPos << 3;
  _15 = _13 << _14;
  _16 = NumberPos * 4;
  _17 = Number + _16;
  _18 = _10 | _15;
  *_17 = _18;

  <bb 9> :
  # DEBUG BEGIN_STMT
  WordPos = WordPos + 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (WordPos <= 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  NumberPos = NumberPos + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  _19 = ArrayLength + 4294967295;
  _20 = _19 / 4;
  _21 = _20 + 1;
  if (NumberPos <= _21)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _22 = ArrayLength + 4294967295;
  _23 = _22 / 4;
  _24 = _23 + 1;
  *Number = _24;
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Number);
  # DEBUG BEGIN_STMT
  RetVal = 0;
  goto <bb 17>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  if (NumberLength == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  RetVal = 1;
  goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  *Number = 0;
  # DEBUG BEGIN_STMT
  RetVal = 0;

  <bb 17> :
  # DEBUG BEGIN_STMT
  D.6615 = RetVal;
  return D.6615;

}


Crypto_LNModulo (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, struct Crypto_LNCtxType * CtxPtr)
{
  uint32 LengthOfMod;
  uint32 LengthOfNum;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  LengthOfNum = Crypto_LNBitLengthOfNumber (Number);
  # DEBUG BEGIN_STMT
  LengthOfMod = Crypto_LNBitLengthOfNumber (Modulus);
  # DEBUG BEGIN_STMT
  if (LengthOfMod == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  *Number = LengthOfMod;
  goto <bb 9>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (LengthOfMod <= LengthOfNum)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _1 = LengthOfNum - LengthOfMod;
  _2 = _1 + 1;
  CtxPtr->LengthDifference = _2;

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Crypto_LNSModuloShift (Number, Modulus, CtxPtr);
  # DEBUG BEGIN_STMT
  _3 = CtxPtr->LengthDifference;
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Number);
  goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Number);

  <bb 9> :
  return;

}


Crypto_LNCompareNumbers (const Crypto_LNWordType * Number1, const Crypto_LNWordType * Number2)
{
  Crypto_ReturnType Compare;
  Crypto_LNWordType NumberPos;
  Crypto_ReturnType D.6569;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = *Number1;
  _2 = *Number2;
  if (_1 > _2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Compare = 5;
  goto <bb 14>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _3 = *Number1;
  _4 = *Number2;
  if (_3 < _4)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Compare = 4;
  goto <bb 14>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Compare = 2;
  # DEBUG BEGIN_STMT
  NumberPos = *Number1;
  goto <bb 12>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _5 = NumberPos * 4;
  _6 = Number1 + _5;
  _7 = *_6;
  _8 = NumberPos * 4;
  _9 = Number2 + _8;
  _10 = *_9;
  if (_7 > _10)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  Compare = 5;
  goto <bb 11>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = NumberPos * 4;
  _12 = Number1 + _11;
  _13 = *_12;
  _14 = NumberPos * 4;
  _15 = Number2 + _14;
  _16 = *_15;
  if (_13 < _16)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  Compare = 4;

  <bb 11> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  NumberPos = NumberPos + 4294967295;

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (NumberPos != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  if (Compare == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  D.6569 = Compare;
  return D.6569;

}


Crypto_LNSubtraction (Crypto_LNWordType * Result, const Crypto_LNWordType * Minuend, const Crypto_LNWordType * Subtrahend)
{
  Crypto_LNWordType Borrow;
  Crypto_LNWordType LoopCount;
  Crypto_LNDoubleWordType TempDifference;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Borrow = 0;
  # DEBUG BEGIN_STMT
  LoopCount = 1;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = LoopCount * 4;
  _2 = Minuend + _1;
  _3 = *_2;
  _4 = (long long unsigned int) _3;
  _5 = LoopCount * 4;
  _6 = Subtrahend + _5;
  _7 = *_6;
  _8 = (long long unsigned int) _7;
  _9 = _4 - _8;
  _10 = (long long unsigned int) Borrow;
  TempDifference = _9 - _10;
  # DEBUG BEGIN_STMT
  _11 = TempDifference >> 32;
  _12 = (long unsigned int) _11;
  Borrow = _12 & 1;
  # DEBUG BEGIN_STMT
  _13 = LoopCount * 4;
  _14 = Result + _13;
  _15 = (long unsigned int) TempDifference;
  *_14 = _15;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _16 = *Subtrahend;
  if (LoopCount <= _16)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _17 = LoopCount * 4;
  _18 = Minuend + _17;
  _19 = *_18;
  _20 = (long long unsigned int) _19;
  _21 = (long long unsigned int) Borrow;
  TempDifference = _20 - _21;
  # DEBUG BEGIN_STMT
  _22 = TempDifference >> 32;
  _23 = (long unsigned int) _22;
  Borrow = _23 & 1;
  # DEBUG BEGIN_STMT
  _24 = LoopCount * 4;
  _25 = Result + _24;
  _26 = (long unsigned int) TempDifference;
  *_25 = _26;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 6> :
  # DEBUG BEGIN_STMT
  _27 = *Minuend;
  if (LoopCount <= _27)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _28 = LoopCount + 4294967295;
  *Result = _28;
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Result);
  return;

}


Crypto_LNMontgomeryReduction (Crypto_LNWordType * Remainder, const Crypto_LNWordType * Number, const Crypto_LNWordType * Modulo, Crypto_LNWordType Rho)
{
  Crypto_LNWordType Temp;
  Crypto_LNDoubleWordType Temp;
  Crypto_LNWordType Pa;
  Crypto_LNWordType * DestPtr;
  Crypto_LNWordType * CPtr;
  Crypto_LNWordType Carry;
  Crypto_LNWordType OldUsed;
  Crypto_LNWordType y;
  Crypto_LNWordType x;
  Crypto_LNWordType Mu;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Pa = *Modulo;
  # DEBUG BEGIN_STMT
  TS_MemBZero32 (&Crypto_MontgomeryReductionC, 36);
  # DEBUG BEGIN_STMT
  OldUsed = *Number;
  # DEBUG BEGIN_STMT
  x = 1;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = x * 4;
  _2 = Number + _1;
  _3 = x + 4294967295;
  _4 = *_2;
  Crypto_MontgomeryReductionC[_3] = _4;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (x <= OldUsed)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  x = 0;
  goto <bb 12>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  Carry = 0;
  # DEBUG BEGIN_STMT
  _5 = Crypto_MontgomeryReductionC[x];
  Mu = Rho * _5;
  # DEBUG BEGIN_STMT
  CPtr = &Crypto_MontgomeryReductionC[x];
  # DEBUG BEGIN_STMT
  y = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = *CPtr;
  _7 = (long long unsigned int) _6;
  _8 = (long long unsigned int) Carry;
  _9 = _7 + _8;
  _10 = (long long unsigned int) Mu;
  _11 = y + 1;
  _12 = _11 * 4;
  _13 = Modulo + _12;
  _14 = *_13;
  _15 = (long long unsigned int) _14;
  _16 = _10 * _15;
  Temp = _9 + _16;
  # DEBUG BEGIN_STMT
  _17 = (long unsigned int) Temp;
  *CPtr = _17;
  # DEBUG BEGIN_STMT
  _18 = Temp >> 32;
  Carry = (Crypto_LNWordType) _18;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  CPtr = CPtr + 4;
  # DEBUG BEGIN_STMT
  y = y + 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (y < Pa)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _19 = *CPtr;
  _20 = Carry + _19;
  *CPtr = _20;
  # DEBUG BEGIN_STMT
  Temp = *CPtr;
  # DEBUG BEGIN_STMT
  _21 = Temp < Carry;
  Carry = (Crypto_LNWordType) _21;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  CPtr = CPtr + 4;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (Carry != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (x < Pa)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  CPtr = &Crypto_MontgomeryReductionC[Pa];
  # DEBUG BEGIN_STMT
  DestPtr = Remainder + 4;
  # DEBUG BEGIN_STMT
  x = 0;
  goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  _22 = x * 4;
  _23 = CPtr + _22;
  _24 = x * 4;
  _25 = DestPtr + _24;
  _26 = *_23;
  *_25 = _26;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 15> :
  # DEBUG BEGIN_STMT
  _27 = Pa + 1;
  if (x < _27)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  _28 = x * 4;
  _29 = DestPtr + _28;
  *_29 = 0;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 17> :
  # DEBUG BEGIN_STMT
  if (x < OldUsed)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  _30 = Pa + 1;
  *Remainder = _30;
  # DEBUG BEGIN_STMT
  Crypto_LNNormalizeNumber (Remainder);
  # DEBUG BEGIN_STMT
  _31 = Crypto_LNCompareNumbers (Remainder, Modulo);
  if (_31 != 4)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  Crypto_LNSubtraction (Remainder, Remainder, Modulo);

  <bb 20> :
  return;

}


Crypto_LNMontgomeryNormalization (Crypto_LNWordType * Result, const Crypto_LNWordType * Modulo)
{
  Crypto_LNWordType WordOffset;
  uint8 Carry;
  uint32 Exponent;
  Crypto_LNWordType x;
  uint32 Bits;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = Crypto_LNBitLengthOfNumber (Modulo);
  Bits = _1 & 31;
  # DEBUG BEGIN_STMT
  if (Bits == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Bits = 32;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _2 = *Modulo;
  if (_2 > 1)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _3 = *Modulo;
  _4 = _3 + 4294967295;
  _5 = _4 * 32;
  _6 = Bits + _5;
  Exponent = _6 + 4294967295;
  # DEBUG BEGIN_STMT
  x = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _7 = x * 4;
  _8 = Result + _7;
  *_8 = 0;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _9 = *Result;
  if (x <= _9)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _10 = Exponent & 31;
  _11 = _10 != 0;
  Carry = (uint8) _11;
  # DEBUG BEGIN_STMT
  WordOffset = Exponent / 32;
  # DEBUG BEGIN_STMT
  _12 = Exponent & 31;
  _13 = (long unsigned int) Carry;
  _14 = WordOffset + _13;
  _15 = _14 * 4;
  _16 = Result + _15;
  _17 = 1 << _12;
  *_16 = _17;
  # DEBUG BEGIN_STMT
  _18 = (long unsigned int) Carry;
  _19 = WordOffset + _18;
  *Result = _19;
  # DEBUG BEGIN_STMT
  goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  *Result = 1;
  # DEBUG BEGIN_STMT
  _20 = Result + 4;
  *_20 = 1;
  # DEBUG BEGIN_STMT
  Bits = 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  x = Bits + 4294967295;
  goto <bb 14>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  Crypto_LNMultByTwo (Result, Result);
  # DEBUG BEGIN_STMT
  _21 = Crypto_LNCompareNumbers (Result, Modulo);
  if (_21 != 4)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  Crypto_LNSubtraction (Result, Result, Modulo);

  <bb 13> :
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 14> :
  # DEBUG BEGIN_STMT
  if (x <= 31)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  return;

}


Crypto_LNMontgomerySetup (const Crypto_LNWordType * Modulo, Crypto_LNWordType * Rho)
{
  Crypto_LNWordType B;
  Crypto_LNWordType X;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  B = MEM[(const Crypto_LNWordType *)Modulo + 4B];
  # DEBUG BEGIN_STMT
  _1 = B + 2;
  _2 = _1 << 1;
  _3 = _2 & 8;
  X = B + _3;
  # DEBUG BEGIN_STMT
  _4 = B * X;
  _5 = 2 - _4;
  X = X * _5;
  # DEBUG BEGIN_STMT
  _6 = B * X;
  _7 = 2 - _6;
  X = X * _7;
  # DEBUG BEGIN_STMT
  _8 = B * X;
  _9 = 2 - _8;
  X = X * _9;
  # DEBUG BEGIN_STMT
  _10 = -X;
  *Rho = _10;
  return;

}


Crypto_LNMultByTwo (Crypto_LNWordType * Result, Crypto_LNWordType * Number)
{
  Crypto_LNWordType * DestPtr;
  Crypto_LNWordType * SrcPtr;
  Crypto_LNWordType NextCarry;
  Crypto_LNWordType Carry;
  Crypto_LNWordType OldUsed;
  Crypto_LNWordType x;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  OldUsed = *Result;
  # DEBUG BEGIN_STMT
  _1 = *Number;
  *Result = _1;
  # DEBUG BEGIN_STMT
  SrcPtr = Number + 4;
  # DEBUG BEGIN_STMT
  DestPtr = Result + 4;
  # DEBUG BEGIN_STMT
  Carry = 0;
  # DEBUG BEGIN_STMT
  x = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _2 = x * 4;
  _3 = SrcPtr + _2;
  _4 = *_3;
  NextCarry = _4 >> 31;
  # DEBUG BEGIN_STMT
  _5 = x * 4;
  _6 = SrcPtr + _5;
  _7 = *_6;
  _8 = _7 << 1;
  _9 = x * 4;
  _10 = DestPtr + _9;
  _11 = Carry | _8;
  *_10 = _11;
  # DEBUG BEGIN_STMT
  Carry = NextCarry;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _12 = *Number;
  if (x < _12)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (Carry != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _13 = x * 4;
  _14 = DestPtr + _13;
  *_14 = 1;
  # DEBUG BEGIN_STMT
  _15 = *Result;
  _16 = _15 + 1;
  *Result = _16;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _17 = *Result;
  _18 = _17 + 1;
  _19 = _18 * 4;
  DestPtr = Result + _19;
  # DEBUG BEGIN_STMT
  x = *Result;
  goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _20 = x * 4;
  _21 = DestPtr + _20;
  *_21 = 0;
  # DEBUG BEGIN_STMT
  x = x + 1;

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (x < OldUsed)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  return;

}


Crypto_LNMultiplyNumbers (Crypto_LNWordType * Result, const Crypto_LNWordType * Multiplicand, const Crypto_LNWordType * Multiplicator, struct Crypto_LNCtxType * CtxPtr)
{
  Crypto_LNDoubleWordType Temp;
  Crypto_LNWordType C2;
  Crypto_LNWordType C1;
  Crypto_LNWordType C0;
  Crypto_LNWordType ProdLen;
  Crypto_LNWordType MultiplicatorLength;
  Crypto_LNWordType MultiplicandLength;
  Crypto_LNWordType Ty;
  Crypto_LNWordType Tx;
  Crypto_LNWordType NumMultiplications;
  Crypto_LNWordType j;
  Crypto_LNWordType i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  MultiplicandLength = *Multiplicand;
  # DEBUG BEGIN_STMT
  MultiplicatorLength = *Multiplicator;
  # DEBUG BEGIN_STMT
  ProdLen = MultiplicandLength + MultiplicatorLength;
  # DEBUG BEGIN_STMT
  C0 = 0;
  # DEBUG BEGIN_STMT
  C1 = 0;
  # DEBUG BEGIN_STMT
  C2 = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = &CtxPtr->LocalResultMultiply;
  TS_MemBZero32 (_1, 47);
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _2 = MultiplicatorLength + 4294967295;
  Ty = MIN_EXPR <i, _2>;
  # DEBUG BEGIN_STMT
  Tx = i - Ty;
  # DEBUG BEGIN_STMT
  _3 = Ty + 1;
  _4 = MultiplicandLength - Tx;
  NumMultiplications = MIN_EXPR <_3, _4>;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  C0 = C1;
  # DEBUG BEGIN_STMT
  C1 = C2;
  # DEBUG BEGIN_STMT
  C2 = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  j = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _5 = (long long unsigned int) C0;
  _6 = Tx + j;
  _7 = _6 + 1;
  _8 = _7 * 4;
  _9 = Multiplicand + _8;
  _10 = *_9;
  _11 = (long long unsigned int) _10;
  _12 = Ty - j;
  _13 = _12 + 1;
  _14 = _13 * 4;
  _15 = Multiplicator + _14;
  _16 = *_15;
  _17 = (long long unsigned int) _16;
  _18 = _11 * _17;
  Temp = _5 + _18;
  # DEBUG BEGIN_STMT
  C0 = (Crypto_LNWordType) Temp;
  # DEBUG BEGIN_STMT
  _19 = (long long unsigned int) C1;
  _20 = Temp >> 32;
  Temp = _19 + _20;
  # DEBUG BEGIN_STMT
  C1 = (Crypto_LNWordType) Temp;
  # DEBUG BEGIN_STMT
  _21 = Temp >> 32;
  _22 = (long unsigned int) _21;
  C2 = C2 + _22;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  j = j + 1;

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (j < NumMultiplications)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _23 = i + 1;
  CtxPtr->LocalResultMultiply[_23] = C0;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (i < ProdLen)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _24 = MultiplicandLength + MultiplicatorLength;
  CtxPtr->LocalResultMultiply[0] = _24;
  # DEBUG BEGIN_STMT
  _25 = &CtxPtr->LocalResultMultiply;
  Crypto_LNNormalizeNumber (_25);
  # DEBUG BEGIN_STMT
  _26 = &CtxPtr->LocalResultMultiply;
  _27 = CtxPtr->LocalResultMultiply[0];
  _28 = _27 + 1;
  _29 = _28 * 4;
  TS_MemCpy32 (Result, _26, _29);
  return;

}


Crypto_LNNormalizeNumber (Crypto_LNWordType * Number)
{
  Crypto_LNWordType i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = *Number;
  # DEBUG BEGIN_STMT
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  i = i + 4294967295;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _1 = i * 4;
  _2 = Number + _1;
  _3 = *_2;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (i != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  *Number = i;
  return;

}


Crypto_LNBitLengthOfNumber (const Crypto_LNWordType * Number)
{
  Crypto_LNWordType Length;
  Crypto_LNWordType TempWord;
  uint32 D.6542;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = *Number;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Length = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _2 = *Number;
  _3 = _2 + 4294967295;
  Length = _3 * 32;
  # DEBUG BEGIN_STMT
  _4 = *Number;
  _5 = _4 * 4;
  _6 = Number + _5;
  TempWord = *_6;
  goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Length = Length + 1;
  # DEBUG BEGIN_STMT
  TempWord = TempWord >> 1;

  <bb 6> :
  # DEBUG BEGIN_STMT
  if (TempWord != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.6542 = Length;
  return D.6542;

}


Crypto_LNIsValid (const Crypto_LNWordType * LongNumber, uint32 PermittedMaxLength)
{
  boolean Status;
  boolean D.6537;

  <bb 2> :
  # DEBUG BEGIN_STMT
  Status = 0;
  # DEBUG BEGIN_STMT
  _1 = *LongNumber;
  if (PermittedMaxLength > _1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _2 = *LongNumber;
  if (_2 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _3 = *LongNumber;
  _4 = _3 * 4;
  _5 = LongNumber + _4;
  _6 = *_5;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Status = 1;

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.6537 = Status;
  return D.6537;

}


Crypto_CommonXOR (void * Destination, const void * Source, uint32 ByteLength)
{
  uint32_least Len;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Len = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = Destination + Len;
  _2 = *_1;
  _3 = Source + Len;
  _4 = *_3;
  _5 = Destination + Len;
  _6 = _2 ^ _4;
  *_5 = _6;
  # DEBUG BEGIN_STMT
  Len = Len + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (Len < ByteLength)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Crypto_LNModuloBarrett (Crypto_LNWordType * Number, const Crypto_LNWordType * Modulus, const Crypto_LNWordType * Barrett, struct Crypto_LNCtxType * CtxPtr)
{
  Crypto_LNWordType * TempNumber;
  Crypto_LNWordType LoopCount;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  LoopCount = *Number;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = LoopCount * 4;
  _2 = Number + _1;
  _3 = LoopCount + 3;
  _4 = _3 * 4;
  _5 = Number + _4;
  _6 = *_2;
  *_5 = _6;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 4294967295;

  <bb 4> :
  # DEBUG BEGIN_STMT
  _7 = *Modulus;
  if (LoopCount >= _7)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _8 = *Modulus;
  _9 = *Number;
  if (_8 > _9)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _10 = *Modulus;
  _11 = _10 + 2;
  _12 = _11 * 4;
  _13 = Number + _12;
  *_13 = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _14 = *Number;
  _15 = *Modulus;
  _16 = _14 - _15;
  _17 = *Modulus;
  _18 = _17 + 2;
  _19 = _18 * 4;
  _20 = Number + _19;
  _21 = _16 + 1;
  *_20 = _21;
  # DEBUG BEGIN_STMT
  _22 = *Modulus;
  _23 = _22 + 1;
  *Number = _23;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _24 = *Modulus;
  _25 = _24 + 2;
  _26 = _25 * 4;
  TempNumber = Number + _26;
  # DEBUG BEGIN_STMT
  Crypto_LNMultiplyNumbers (TempNumber, TempNumber, Barrett, CtxPtr);
  # DEBUG BEGIN_STMT
  _27 = *Modulus;
  _28 = *TempNumber;
  if (_27 >= _28)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  *TempNumber = 0;
  goto <bb 14>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _29 = *Modulus;
  LoopCount = _29 + 2;
  goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _30 = LoopCount * 4;
  _31 = TempNumber + _30;
  _32 = *Modulus;
  _33 = LoopCount - _32;
  _34 = _33 + 4294967295;
  _35 = _34 * 4;
  _36 = TempNumber + _35;
  _37 = *_31;
  *_36 = _37;
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  _38 = *TempNumber;
  if (LoopCount <= _38)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _39 = *TempNumber;
  _40 = *Modulus;
  _41 = _39 - _40;
  _42 = _41 + 4294967295;
  *TempNumber = _42;

  <bb 14> :
  # DEBUG BEGIN_STMT
  Crypto_LNMultiplyNumbers (TempNumber, TempNumber, Modulus, CtxPtr);
  # DEBUG BEGIN_STMT
  _43 = *Modulus;
  _44 = _43 + 1;
  _45 = *TempNumber;
  if (_44 < _45)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  _46 = *Modulus;
  _47 = _46 + 1;
  *TempNumber = _47;

  <bb 16> :
  # DEBUG BEGIN_STMT
  _48 = *Modulus;
  _49 = _48 + 1;
  Crypto_LNBarretSubtractNumbers (Number, Number, TempNumber, _49);
  # DEBUG BEGIN_STMT
  LoopCount = 0;
  # DEBUG BEGIN_STMT
  goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  Crypto_LNBarretSubtractNumbers (Number, Number, Modulus, 4294967295);
  # DEBUG BEGIN_STMT
  LoopCount = LoopCount + 1;

  <bb 18> :
  # DEBUG BEGIN_STMT
  _50 = Crypto_LNCompareNumbers (Number, Modulus);
  if (_50 != 4)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  if (LoopCount <= 3)
    goto <bb 17>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  if (LoopCount == 4)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  # DEBUG BEGIN_STMT
  *Number = 0;

  <bb 22> :
  return;

}


Crypto_CheckSkipMain (Std_ReturnType * Result, boolean * Busy, const uint32 ObjId)
{
  boolean SkipMain;
  boolean D.6517;

  <bb 2> :
  # DEBUG BEGIN_STMT
  SkipMain = 0;
  # DEBUG BEGIN_STMT
  if (Result == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  if (Busy == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _1 = Crypto_DriverObjects[ObjId].SkipPeriodicMainFunction;
  if (_1 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  SkipMain = 1;

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.6517 = SkipMain;
  return D.6517;

}


Crypto_StateMachineIdle ()
{
  Std_ReturnType D.6509;

  <bb 2> :
  # DEBUG BEGIN_STMT
  D.6509 = 0;
  return D.6509;

}


Crypto_MemCmp_Sec (const uint8 * const A, const uint8 * const B, uint32 Length)
{
  uint32 Counter;
  uint8 Result;
  Std_ReturnType RetVal;
  Std_ReturnType D.6507;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Result = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  Counter = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = A + Counter;
  _2 = *_1;
  _3 = B + Counter;
  _4 = *_3;
  _5 = _2 ^ _4;
  Result = Result | _5;
  # DEBUG BEGIN_STMT
  Counter = Counter + 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (Counter < Length)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (Result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  RetVal = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  RetVal = 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.6507 = RetVal;
  return D.6507;

}


Crypto_MemCmp (const uint8 * const A, const uint8 * const B, uint32 Length)
{
  Std_ReturnType D.6502;

  <bb 2> :
  # DEBUG BEGIN_STMT
  D.6502 = TS_MemCmp32 (A, B, Length);
  return D.6502;

}


