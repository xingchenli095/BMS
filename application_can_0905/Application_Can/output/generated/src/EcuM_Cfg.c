/**
 * \file
 *
 * \brief AUTOSAR EcuM
 *
 * This file contains the implementation of the AUTOSAR
 * module EcuM.
 *
 * \version 5.15.10
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2022 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
/* !LINKSTO EcuM.Config.EcuMMainFunctionPeriod, 1 */





/*==================[inclusions]============================================*/

#include <Mcu.h>          /* MCU module types                  */
/* Macro for preventing redundant declarations of EcuM_MainFunction(),
 * since the function prototype is also generated by the SchM. */
#define ECUM_INTERNAL_USE
#include <EcuM.h>
#include <EcuM_Int.h>     /* EcuM private header               */
#include <EcuM_Cfg.h>
#include <SchM_EcuM.h>           /* SchM API for EcuM */

#include <Det.h>
#include <OsIf.h>
#include <Dem.h>
#include <Eb_Intgr_McuArchClockInit.h>
#include <Port.h>
#include <PbcfgM.h>
#include <Wdg.h>



/*------------------[MultiCore variables]-----------------------------------------------*/


#if(defined ECUM_GET_CORE_ID)
#error ECUM_GET_CORE_ID already defined
#endif
#if (ECUM_MULTICORE_ENABLED == TRUE)
/** \brief Returns the core ID that is currently active. */
#define ECUM_GET_CORE_ID() GetCoreID()
#else
#define ECUM_GET_CORE_ID() 0U
#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);

STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id);

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[external constants]====================================*/
#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/* Wake-up Source ID mapping */
CONST(uint8, ECUM_CONST) EcuM_WksMapping[ECUM_WKS_ID_MAXVAL + 1U] =
{
  0U,
  1U,
  2U,
  3U,
  4U,
  5U,
};

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h>


#define ECUM_START_SEC_CONST_16
#include <EcuM_MemMap.h>

/* !LINKSTO EcuM4004,1 */
/* timeout for wakeup source */
CONST(uint16, ECUM_CONST) EcuM_WksValTimeout[ECUM_WKSCONFIGNUM] =
{
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_POWER */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_WDG */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_EXTERNAL_WDG */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_CAN */
};

#define ECUM_STOP_SEC_CONST_16
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>


/*------------------[Wakeup Sources]----------------------------------------*/

/* configurations of Wakeup Sources */
CONST(EcuM_WksConfigType, ECUM_CONST) EcuM_WksConfigList[ECUM_WKSCONFIGNUM] =
{
/* !LINKSTO EcuM2166,1 */
  /* ECUM_WKSOURCE_POWER */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_POWER_ON_RESET,   /* Reset Reason */
    0U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    1U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    2U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    3U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_EXTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    4U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_CAN */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    0U,   /* ComM Channel Id */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    5U   /* Wakeup Source Id */
  },
};

/*------------------[Sleep Modes]-------------------------------------------*/
CONST(EcuM_SleepModeConfigType, ECUM_CONST) EcuM_SleepModeConfigList[ECUM_SLEEPMODECONFIGNUM] =
{

  {
    
    ECUM_EcuMSleepMode_0_WKUP_MASK, /* Wakeup event mask of sleep mode EcuMSleepMode_0 */
    /* Sleep mode: EcuMSleepMode_0, ID: 0 */
    #if (defined McuConf_McuModeSettingConf_McuModeSettingConf_0)
    McuConf_McuModeSettingConf_McuModeSettingConf_0,
    #else
    McuModeSettingConf_0,
    #endif
    TRUE/* Suspend flag */
  },

};

/*------------------[Errors reporting to Dem]-------------------------------------------*/

CONST(Dem_EventIdType, ECUM_CONST) EcuM_DemErrRamChkFailed =
  7U;  /* Error for Ram check failure */


#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/*------------------[EcuMShutdownCause]-------------------------------------------*/

#if (ECUM_DEV_ERROR_DETECT == STD_ON)
/* Array holding the configured values of Shutdown Causes */
CONST(EcuM_ShutdownCauseType, ECUM_CONST)
   EcuM_ValidShutdownCause[ECUM_SHUTDOWNCAUSECONFIGNUM] =
{
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_ECU_STATE,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_UNKNOWN,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_WDGM,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_DCM,
};
#endif

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h> 

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/** \brief The initial core context for a single core. */
CONST(EcuM_CoreContextType, ECUM_CONST) EcuM_InitialContext =
{
  {
    /* WAKEUP STATUS */
    ECUM_WKSMASKALL,  /* Disabled */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
    0U, /* Expired */
    0U, /* Started */
    0U, /* Stopped */
  },
  {
    /* WAKEUP INDICATION */
    0U, /* Disabled */
    0U, /* Expired */
    0U, /* None */
    0U, /* Pending */
    0U, /* Validated */
  },
  0U, /* WAKEUP SOURCE VALIDATION COUNTER */
  0U, /* EcuM State */
  0U,  /* EcuM Sleep Mode */
};


#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*------------[EcuM Multi-Core internal data]---------------*/

/* !LINKSTO EcuM.Impl.MemoryMapping.InstanceData,1 */
#define ECUM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of the EcuM
 ** master core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core0_Context;

#define ECUM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>


#define ECUM_START_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

VAR(EcuM_ShutdownInfoType, ECUM_VAR_POWER_ON_INIT)
  EcuM_ShutdownInfo[ECUM_STORED_SHUTDOWN_OPERATIONS] = {
    {0U, 0U, 0U, 0U}
  };

#define ECUM_STOP_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include <EcuM_MemMap.h>

/*==================[external function definitions]=========================*/
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/*------------------[Callouts from STARTUP state]---------------------------*/

/* Configured Initialization List Zero items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListZero(void)
{
  /* *** Call service Init of module Det *** */
  Det_Init();
}


/* Configured Initialization List One items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListOne(void)
{
  uint8 i;

  for (i = 0; i < ECUM_NUM_DRIVERS_INIT_LIST_ONE; i++ )
  {
    EcuM_DriverInitListOneCall(ECUM_DRIVER_INIT_LIST_ONE(i));
  }
}

/*------------------[Callouts from SLEEP state]--------------------------*/
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
/*==================[internal function definitions]=========================*/

/*------------[EcuM Multi-Core internal function definitions]---------------*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_EnterExclusiveArea(void)
{

  EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

FUNC(void, ECUM_CODE) EcuM_ExitExclusiveArea(void)
{

  EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}


#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#if (ECUM_MULTICORE_ENABLED == TRUE)

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_GetResourceScheduler(void)
{
#ifdef OS_AUTOSAROS_VER
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
#endif

#ifndef OS_AUTOSAROS_VER
  (void)GetResource(RES_SCHEDULER);
#else
  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_0);
#endif
       break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
#endif /* #ifndef OS_AUTOSAROS_VER */
}

FUNC(void, ECUM_CODE) EcuM_ReleaseResourceScheduler(void)
{
#ifdef OS_AUTOSAROS_VER
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
#endif

#ifndef OS_AUTOSAROS_VER
  (void)ReleaseResource(RES_SCHEDULER);
#else
  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_0);
#endif
       break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
#endif /* #ifndef OS_AUTOSAROS_VER */
}

FUNC(Std_ReturnType, ECUM_CODE) EcuM_Send_SlaveCoreReadyPort(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  Std_ReturnType ret = E_NOT_OK;
  Std_ReturnType schMSendResult;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
      switch(coreID)
      {
        default:
        {
          break;
        }
      }
  }

  return ret;
}

/* !LINKSTO EcuM.Impl.EcuM_MasterCoreSync,1 */
/* !LINKSTO EcuM.Impl.Source.SlaveMasterCoreSync,1 */
FUNC(Std_ReturnType, ECUM_CODE) EcuM_MasterCoreSync(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
  EcuM_SyncActionType syncResult = ECUM_CONTINUE_SYNC;
  Std_ReturnType schMReceiveResult = E_NOT_OK;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
    boolean EcuM_IsMasterReady = FALSE;
    do
    {
      switch(coreID)
      {
        default:
        {
          break;
        }
      }
      if (TRUE == EcuM_IsMasterReady)
      {
        break;
      }
      /* !LINKSTO EcuM.Impl.EcuM_OnCoreSync,1 */
      syncResult = EcuM_OnCoreSync();
    } while (syncResult != ECUM_ABORT_SYNC);
  }

  return ((ECUM_CONTINUE_SYNC == syncResult) && (schMReceiveResult == SCHM_E_OK)) ? E_OK : E_NOT_OK;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>


#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/* !LINKSTO EcuM.Impl.EcuM_GetCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetCoreInstance(void)
{
  P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA) inst = NULL_PTR;

#if (ECUM_MULTICORE_ENABLED == TRUE)
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
      inst = &EcuM_Core0_Context;
      break;
    }
    default:
    {
      /* No EcuM instance exists for core. */
      break;
    }
  }
#else
  inst = &EcuM_Core0_Context;
#endif

  return inst;
}

/* !LINKSTO EcuM.Impl.EcuM_GetMasterCoreInstance,1 */
FUNC_P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_CODE) EcuM_GetMasterCoreInstance(void)
{
  return &EcuM_Core0_Context;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>



#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

STATIC FUNC(void, ECUM_CODE) EcuM_DriverInitListOneCall(uint8 id)
{
    switch (id)
    {
      case 0:
      {
        /* *** Call service Init of module OsIf *** */
        OsIf_Init(NULL_PTR);
        break;
      }
      case 1:
      {
        /* *** Call service PreInit of module Dem *** */
        Dem_PreInit(&DemConfigSet);
        break;
      }
      case 2:
      {
        /* *** Call service Init of module Mcu *** */
        Mcu_Init(BASE_MCU_CONFIG_PTR);
        break;
      }
      case 3:
      {
        /* *** Call service Init of module Eb_Intgr_McuArchClockInit *** */
        Eb_Intgr_McuArchClockInit_Init();
        break;
      }
      case 4:
      {
        /* *** Call service Init of module Port *** */
        Port_Init(&Port_Config);
        break;
      }
      case 5:
      {
        /* *** Call service Init of module PbcfgM *** */
        PbcfgM_Init(BASE_PBCFGM_CONFIG_PTR);
        break;
      }
      case 6:
      {
        /* *** Call service Init of module Wdg *** */
        Wdg_Init(NULL_PTR);
        break;
      }
      default:
      {
        /* No driver configured. */
        break;
      }
    }
}


#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[end of file]===========================================*/

